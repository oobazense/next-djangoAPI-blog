(()=>{var __webpack_modules__={773:e=>{e.exports='"use strict";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);\n\n// src/primitives/abort-controller.js\nvar abort_controller_exports = {};\n__export(abort_controller_exports, {\n  AbortController: () => AbortController,\n  AbortSignal: () => AbortSignal,\n  DOMException: () => DOMException\n});\nmodule.exports = __toCommonJS(abort_controller_exports);\nvar kSignal = Symbol("kSignal");\nvar kAborted = Symbol("kAborted");\nvar kReason = Symbol("kReason");\nvar kName = Symbol("kName");\nvar kOnabort = Symbol("kOnabort");\nvar DOMException = class extends Error {\n  constructor(message, name) {\n    super(message);\n    this[kName] = name;\n  }\n  get name() {\n    return this[kName];\n  }\n};\n__name(DOMException, "DOMException");\nfunction createAbortSignal() {\n  const signal = new EventTarget();\n  Object.setPrototypeOf(signal, AbortSignal.prototype);\n  signal[kAborted] = false;\n  signal[kReason] = void 0;\n  signal[kOnabort] = void 0;\n  return signal;\n}\n__name(createAbortSignal, "createAbortSignal");\nfunction abortSignalAbort(signal, reason) {\n  if (typeof reason === "undefined") {\n    reason = new DOMException("The operation was aborted.", "AbortError");\n  }\n  if (signal.aborted) {\n    return;\n  }\n  signal[kReason] = reason;\n  signal[kAborted] = true;\n  signal.dispatchEvent(new Event("abort"));\n}\n__name(abortSignalAbort, "abortSignalAbort");\nvar AbortController = class {\n  constructor() {\n    this[kSignal] = createAbortSignal();\n  }\n  get signal() {\n    return this[kSignal];\n  }\n  abort(reason) {\n    abortSignalAbort(this.signal, reason);\n  }\n};\n__name(AbortController, "AbortController");\nvar AbortSignal = class extends EventTarget {\n  constructor() {\n    throw new TypeError("Illegal constructor.");\n  }\n  get aborted() {\n    return this[kAborted];\n  }\n  get reason() {\n    return this[kReason];\n  }\n  get onabort() {\n    return this[kOnabort];\n  }\n  set onabort(value) {\n    if (this[kOnabort]) {\n      this.removeEventListener("abort", this[kOnabort]);\n    }\n    if (value) {\n      this[kOnabort] = value;\n      this.addEventListener("abort", this[kOnabort]);\n    }\n  }\n  throwIfAborted() {\n    if (this[kAborted]) {\n      throw this[kReason];\n    }\n  }\n  static abort(reason) {\n    const signal = createAbortSignal();\n    abortSignalAbort(signal, reason);\n    return signal;\n  }\n  static timeout(milliseconds) {\n    const signal = createAbortSignal();\n    setTimeout(() => {\n      abortSignalAbort(\n        signal,\n        new DOMException("The operation timed out.", "TimeoutError")\n      );\n    }, milliseconds);\n    return signal;\n  }\n};\n__name(AbortSignal, "AbortSignal");\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  AbortController,\n  AbortSignal,\n  DOMException\n});\n'},616:e=>{e.exports='"use strict";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. "__esModule" has not been set), then set\n  // "default" to the CommonJS "module.exports" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);\n\n// <define:process>\nvar init_define_process = __esm({\n  "<define:process>"() {\n  }\n});\n\n// ../../node_modules/.pnpm/blob-polyfill@7.0.20220408/node_modules/blob-polyfill/Blob.js\nvar require_Blob = __commonJS({\n  "../../node_modules/.pnpm/blob-polyfill@7.0.20220408/node_modules/blob-polyfill/Blob.js"(exports) {\n    init_define_process();\n    (function(global2) {\n      (function(factory) {\n        if (typeof define === "function" && define.amd) {\n          define(["exports"], factory);\n        } else if (typeof exports === "object" && typeof exports.nodeName !== "string") {\n          factory(exports);\n        } else {\n          factory(global2);\n        }\n      })(function(exports2) {\n        "use strict";\n        var BlobBuilder = global2.BlobBuilder || global2.WebKitBlobBuilder || global2.MSBlobBuilder || global2.MozBlobBuilder;\n        var URL = global2.URL || global2.webkitURL || function(href, a) {\n          a = document.createElement("a");\n          a.href = href;\n          return a;\n        };\n        var origBlob = global2.Blob;\n        var createObjectURL = URL.createObjectURL;\n        var revokeObjectURL = URL.revokeObjectURL;\n        var strTag = global2.Symbol && global2.Symbol.toStringTag;\n        var blobSupported = false;\n        var blobSupportsArrayBufferView = false;\n        var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;\n        try {\n          blobSupported = new Blob(["\\xE4"]).size === 2;\n          blobSupportsArrayBufferView = new Blob([new Uint8Array([1, 2])]).size === 2;\n        } catch (e) {\n        }\n        function mapArrayBufferViews(ary) {\n          return ary.map(function(chunk) {\n            if (chunk.buffer instanceof ArrayBuffer) {\n              var buf = chunk.buffer;\n              if (chunk.byteLength !== buf.byteLength) {\n                var copy = new Uint8Array(chunk.byteLength);\n                copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));\n                buf = copy.buffer;\n              }\n              return buf;\n            }\n            return chunk;\n          });\n        }\n        __name(mapArrayBufferViews, "mapArrayBufferViews");\n        function BlobBuilderConstructor(ary, options) {\n          options = options || {};\n          var bb = new BlobBuilder();\n          mapArrayBufferViews(ary).forEach(function(part) {\n            bb.append(part);\n          });\n          return options.type ? bb.getBlob(options.type) : bb.getBlob();\n        }\n        __name(BlobBuilderConstructor, "BlobBuilderConstructor");\n        function BlobConstructor(ary, options) {\n          return new origBlob(mapArrayBufferViews(ary), options || {});\n        }\n        __name(BlobConstructor, "BlobConstructor");\n        if (global2.Blob) {\n          BlobBuilderConstructor.prototype = Blob.prototype;\n          BlobConstructor.prototype = Blob.prototype;\n        }\n        function stringEncode(string) {\n          var pos = 0;\n          var len = string.length;\n          var Arr = global2.Uint8Array || Array;\n          var at = 0;\n          var tlen = Math.max(32, len + (len >> 1) + 7);\n          var target = new Arr(tlen >> 3 << 3);\n          while (pos < len) {\n            var value = string.charCodeAt(pos++);\n            if (value >= 55296 && value <= 56319) {\n              if (pos < len) {\n                var extra = string.charCodeAt(pos);\n                if ((extra & 64512) === 56320) {\n                  ++pos;\n                  value = ((value & 1023) << 10) + (extra & 1023) + 65536;\n                }\n              }\n              if (value >= 55296 && value <= 56319) {\n                continue;\n              }\n            }\n            if (at + 4 > target.length) {\n              tlen += 8;\n              tlen *= 1 + pos / string.length * 2;\n              tlen = tlen >> 3 << 3;\n              var update = new Uint8Array(tlen);\n              update.set(target);\n              target = update;\n            }\n            if ((value & 4294967168) === 0) {\n              target[at++] = value;\n              continue;\n            } else if ((value & 4294965248) === 0) {\n              target[at++] = value >> 6 & 31 | 192;\n            } else if ((value & 4294901760) === 0) {\n              target[at++] = value >> 12 & 15 | 224;\n              target[at++] = value >> 6 & 63 | 128;\n            } else if ((value & 4292870144) === 0) {\n              target[at++] = value >> 18 & 7 | 240;\n              target[at++] = value >> 12 & 63 | 128;\n              target[at++] = value >> 6 & 63 | 128;\n            } else {\n              continue;\n            }\n            target[at++] = value & 63 | 128;\n          }\n          return target.slice(0, at);\n        }\n        __name(stringEncode, "stringEncode");\n        function stringDecode(buf) {\n          var end = buf.length;\n          var res = [];\n          var i = 0;\n          while (i < end) {\n            var firstByte = buf[i];\n            var codePoint = null;\n            var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n            if (i + bytesPerSequence <= end) {\n              var secondByte, thirdByte, fourthByte, tempCodePoint;\n              switch (bytesPerSequence) {\n                case 1:\n                  if (firstByte < 128) {\n                    codePoint = firstByte;\n                  }\n                  break;\n                case 2:\n                  secondByte = buf[i + 1];\n                  if ((secondByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                    if (tempCodePoint > 127) {\n                      codePoint = tempCodePoint;\n                    }\n                  }\n                  break;\n                case 3:\n                  secondByte = buf[i + 1];\n                  thirdByte = buf[i + 2];\n                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                    if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                      codePoint = tempCodePoint;\n                    }\n                  }\n                  break;\n                case 4:\n                  secondByte = buf[i + 1];\n                  thirdByte = buf[i + 2];\n                  fourthByte = buf[i + 3];\n                  if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                    tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                    if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                      codePoint = tempCodePoint;\n                    }\n                  }\n              }\n            }\n            if (codePoint === null) {\n              codePoint = 65533;\n              bytesPerSequence = 1;\n            } else if (codePoint > 65535) {\n              codePoint -= 65536;\n              res.push(codePoint >>> 10 & 1023 | 55296);\n              codePoint = 56320 | codePoint & 1023;\n            }\n            res.push(codePoint);\n            i += bytesPerSequence;\n          }\n          var len = res.length;\n          var str = "";\n          var j = 0;\n          while (j < len) {\n            str += String.fromCharCode.apply(String, res.slice(j, j += 4096));\n          }\n          return str;\n        }\n        __name(stringDecode, "stringDecode");\n        var textEncode = typeof TextEncoder === "function" ? TextEncoder.prototype.encode.bind(new TextEncoder()) : stringEncode;\n        var textDecode = typeof TextDecoder === "function" ? TextDecoder.prototype.decode.bind(new TextDecoder()) : stringDecode;\n        function FakeBlobBuilder() {\n          function bufferClone(buf) {\n            var view = new Array(buf.byteLength);\n            var array = new Uint8Array(buf);\n            var i = view.length;\n            while (i--) {\n              view[i] = array[i];\n            }\n            return view;\n          }\n          __name(bufferClone, "bufferClone");\n          function array2base64(input) {\n            var byteToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";\n            var output = [];\n            for (var i = 0; i < input.length; i += 3) {\n              var byte1 = input[i];\n              var haveByte2 = i + 1 < input.length;\n              var byte2 = haveByte2 ? input[i + 1] : 0;\n              var haveByte3 = i + 2 < input.length;\n              var byte3 = haveByte3 ? input[i + 2] : 0;\n              var outByte1 = byte1 >> 2;\n              var outByte2 = (byte1 & 3) << 4 | byte2 >> 4;\n              var outByte3 = (byte2 & 15) << 2 | byte3 >> 6;\n              var outByte4 = byte3 & 63;\n              if (!haveByte3) {\n                outByte4 = 64;\n                if (!haveByte2) {\n                  outByte3 = 64;\n                }\n              }\n              output.push(\n                byteToCharMap[outByte1],\n                byteToCharMap[outByte2],\n                byteToCharMap[outByte3],\n                byteToCharMap[outByte4]\n              );\n            }\n            return output.join("");\n          }\n          __name(array2base64, "array2base64");\n          var create = Object.create || function(a) {\n            function c() {\n            }\n            __name(c, "c");\n            c.prototype = a;\n            return new c();\n          };\n          function getObjectTypeName(o) {\n            return Object.prototype.toString.call(o).slice(8, -1);\n          }\n          __name(getObjectTypeName, "getObjectTypeName");\n          function isPrototypeOf(c, o) {\n            return typeof c === "object" && Object.prototype.isPrototypeOf.call(c.prototype, o);\n          }\n          __name(isPrototypeOf, "isPrototypeOf");\n          function isDataView(o) {\n            return getObjectTypeName(o) === "DataView" || isPrototypeOf(global2.DataView, o);\n          }\n          __name(isDataView, "isDataView");\n          var arrayBufferClassNames = [\n            "Int8Array",\n            "Uint8Array",\n            "Uint8ClampedArray",\n            "Int16Array",\n            "Uint16Array",\n            "Int32Array",\n            "Uint32Array",\n            "Float32Array",\n            "Float64Array",\n            "ArrayBuffer"\n          ];\n          function includes(a, v) {\n            return a.indexOf(v) !== -1;\n          }\n          __name(includes, "includes");\n          function isArrayBuffer(o) {\n            return includes(arrayBufferClassNames, getObjectTypeName(o)) || isPrototypeOf(global2.ArrayBuffer, o);\n          }\n          __name(isArrayBuffer, "isArrayBuffer");\n          function concatTypedarrays(chunks) {\n            var size = 0;\n            var j = chunks.length;\n            while (j--) {\n              size += chunks[j].length;\n            }\n            var b = new Uint8Array(size);\n            var offset = 0;\n            for (var i = 0; i < chunks.length; i++) {\n              var chunk = chunks[i];\n              b.set(chunk, offset);\n              offset += chunk.byteLength || chunk.length;\n            }\n            return b;\n          }\n          __name(concatTypedarrays, "concatTypedarrays");\n          function Blob3(chunks, opts) {\n            chunks = chunks ? chunks.slice() : [];\n            opts = opts == null ? {} : opts;\n            for (var i = 0, len = chunks.length; i < len; i++) {\n              var chunk = chunks[i];\n              if (chunk instanceof Blob3) {\n                chunks[i] = chunk._buffer;\n              } else if (typeof chunk === "string") {\n                chunks[i] = textEncode(chunk);\n              } else if (isDataView(chunk)) {\n                chunks[i] = bufferClone(chunk.buffer);\n              } else if (isArrayBuffer(chunk)) {\n                chunks[i] = bufferClone(chunk);\n              } else {\n                chunks[i] = textEncode(String(chunk));\n              }\n            }\n            this._buffer = global2.Uint8Array ? concatTypedarrays(chunks) : [].concat.apply([], chunks);\n            this.size = this._buffer.length;\n            this.type = opts.type || "";\n            if (/[^\\u0020-\\u007E]/.test(this.type)) {\n              this.type = "";\n            } else {\n              this.type = this.type.toLowerCase();\n            }\n          }\n          __name(Blob3, "Blob");\n          Blob3.prototype.arrayBuffer = function() {\n            return Promise.resolve(this._buffer.buffer || this._buffer);\n          };\n          Blob3.prototype.text = function() {\n            return Promise.resolve(textDecode(this._buffer));\n          };\n          Blob3.prototype.slice = function(start, end, type) {\n            var slice = this._buffer.slice(start || 0, end || this._buffer.length);\n            return new Blob3([slice], { type });\n          };\n          Blob3.prototype.toString = function() {\n            return "[object Blob]";\n          };\n          function File2(chunks, name, opts) {\n            opts = opts || {};\n            var a = Blob3.call(this, chunks, opts) || this;\n            a.name = name.replace(/\\//g, ":");\n            a.lastModifiedDate = opts.lastModified ? new Date(opts.lastModified) : /* @__PURE__ */ new Date();\n            a.lastModified = +a.lastModifiedDate;\n            return a;\n          }\n          __name(File2, "File");\n          File2.prototype = create(Blob3.prototype);\n          File2.prototype.constructor = File2;\n          if (Object.setPrototypeOf) {\n            Object.setPrototypeOf(File2, Blob3);\n          } else {\n            try {\n              File2.__proto__ = Blob3;\n            } catch (e) {\n            }\n          }\n          File2.prototype.toString = function() {\n            return "[object File]";\n          };\n          function FileReader2() {\n            if (!(this instanceof FileReader2)) {\n              throw new TypeError("Failed to construct \'FileReader\': Please use the \'new\' operator, this DOM object constructor cannot be called as a function.");\n            }\n            var delegate = document.createDocumentFragment();\n            this.addEventListener = delegate.addEventListener;\n            this.dispatchEvent = function(evt) {\n              var local = this["on" + evt.type];\n              if (typeof local === "function")\n                local(evt);\n              delegate.dispatchEvent(evt);\n            };\n            this.removeEventListener = delegate.removeEventListener;\n          }\n          __name(FileReader2, "FileReader");\n          function _read(fr, blob2, kind) {\n            if (!(blob2 instanceof Blob3)) {\n              throw new TypeError("Failed to execute \'" + kind + "\' on \'FileReader\': parameter 1 is not of type \'Blob\'.");\n            }\n            fr.result = "";\n            setTimeout(function() {\n              this.readyState = FileReader2.LOADING;\n              fr.dispatchEvent(new Event("load"));\n              fr.dispatchEvent(new Event("loadend"));\n            });\n          }\n          __name(_read, "_read");\n          FileReader2.EMPTY = 0;\n          FileReader2.LOADING = 1;\n          FileReader2.DONE = 2;\n          FileReader2.prototype.error = null;\n          FileReader2.prototype.onabort = null;\n          FileReader2.prototype.onerror = null;\n          FileReader2.prototype.onload = null;\n          FileReader2.prototype.onloadend = null;\n          FileReader2.prototype.onloadstart = null;\n          FileReader2.prototype.onprogress = null;\n          FileReader2.prototype.readAsDataURL = function(blob2) {\n            _read(this, blob2, "readAsDataURL");\n            this.result = "data:" + blob2.type + ";base64," + array2base64(blob2._buffer);\n          };\n          FileReader2.prototype.readAsText = function(blob2) {\n            _read(this, blob2, "readAsText");\n            this.result = textDecode(blob2._buffer);\n          };\n          FileReader2.prototype.readAsArrayBuffer = function(blob2) {\n            _read(this, blob2, "readAsText");\n            this.result = (blob2._buffer.buffer || blob2._buffer).slice();\n          };\n          FileReader2.prototype.abort = function() {\n          };\n          URL.createObjectURL = function(blob2) {\n            return blob2 instanceof Blob3 ? "data:" + blob2.type + ";base64," + array2base64(blob2._buffer) : createObjectURL.call(URL, blob2);\n          };\n          URL.revokeObjectURL = function(url) {\n            revokeObjectURL && revokeObjectURL.call(URL, url);\n          };\n          var _send = global2.XMLHttpRequest && global2.XMLHttpRequest.prototype.send;\n          if (_send) {\n            XMLHttpRequest.prototype.send = function(data) {\n              if (data instanceof Blob3) {\n                this.setRequestHeader("Content-Type", data.type);\n                _send.call(this, textDecode(data._buffer));\n              } else {\n                _send.call(this, data);\n              }\n            };\n          }\n          exports2.Blob = Blob3;\n          exports2.File = File2;\n          exports2.FileReader = FileReader2;\n          exports2.URL = URL;\n        }\n        __name(FakeBlobBuilder, "FakeBlobBuilder");\n        function fixFileAndXHR() {\n          var isIE = !!global2.ActiveXObject || "-ms-scroll-limit" in document.documentElement.style && "-ms-ime-align" in document.documentElement.style;\n          var _send = global2.XMLHttpRequest && global2.XMLHttpRequest.prototype.send;\n          if (isIE && _send) {\n            XMLHttpRequest.prototype.send = function(data) {\n              if (data instanceof Blob) {\n                this.setRequestHeader("Content-Type", data.type);\n                _send.call(this, data);\n              } else {\n                _send.call(this, data);\n              }\n            };\n          }\n          try {\n            new File([], "");\n            exports2.File = global2.File;\n            exports2.FileReader = global2.FileReader;\n          } catch (e) {\n            try {\n              exports2.File = new Function(\n                \'class File extends Blob {constructor(chunks, name, opts) {opts = opts || {};super(chunks, opts || {});this.name = name.replace(/\\\\//g, ":");this.lastModifiedDate = opts.lastModified ? new Date(opts.lastModified) : new Date();this.lastModified = +this.lastModifiedDate;}};return new File([], ""), File\'\n              )();\n            } catch (e2) {\n              exports2.File = function(b, d, c) {\n                var blob2 = new Blob(b, c);\n                var t = c && void 0 !== c.lastModified ? new Date(c.lastModified) : /* @__PURE__ */ new Date();\n                blob2.name = d.replace(/\\//g, ":");\n                blob2.lastModifiedDate = t;\n                blob2.lastModified = +t;\n                blob2.toString = function() {\n                  return "[object File]";\n                };\n                if (strTag) {\n                  blob2[strTag] = "File";\n                }\n                return blob2;\n              };\n            }\n          }\n        }\n        __name(fixFileAndXHR, "fixFileAndXHR");\n        if (blobSupported) {\n          fixFileAndXHR();\n          exports2.Blob = blobSupportsArrayBufferView ? global2.Blob : BlobConstructor;\n        } else if (blobBuilderSupported) {\n          fixFileAndXHR();\n          exports2.Blob = BlobBuilderConstructor;\n        } else {\n          FakeBlobBuilder();\n        }\n        if (strTag) {\n          if (!exports2.File.prototype[strTag])\n            exports2.File.prototype[strTag] = "File";\n          if (!exports2.Blob.prototype[strTag])\n            exports2.Blob.prototype[strTag] = "Blob";\n          if (!exports2.FileReader.prototype[strTag])\n            exports2.FileReader.prototype[strTag] = "FileReader";\n        }\n        var blob = exports2.Blob.prototype;\n        var stream;\n        try {\n          new ReadableStream({ type: "bytes" });\n          stream = /* @__PURE__ */ __name(function stream2() {\n            var position = 0;\n            var blob2 = this;\n            return new ReadableStream({\n              type: "bytes",\n              autoAllocateChunkSize: 524288,\n              pull: function(controller) {\n                var v = controller.byobRequest.view;\n                var chunk = blob2.slice(position, position + v.byteLength);\n                return chunk.arrayBuffer().then(function(buffer) {\n                  var uint8array = new Uint8Array(buffer);\n                  var bytesRead = uint8array.byteLength;\n                  position += bytesRead;\n                  v.set(uint8array);\n                  controller.byobRequest.respond(bytesRead);\n                  if (position >= blob2.size)\n                    controller.close();\n                });\n              }\n            });\n          }, "stream");\n        } catch (e) {\n          try {\n            new ReadableStream({});\n            stream = /* @__PURE__ */ __name(function stream2(blob2) {\n              var position = 0;\n              return new ReadableStream({\n                pull: function(controller) {\n                  var chunk = blob2.slice(position, position + 524288);\n                  return chunk.arrayBuffer().then(function(buffer) {\n                    position += buffer.byteLength;\n                    var uint8array = new Uint8Array(buffer);\n                    controller.enqueue(uint8array);\n                    if (position == blob2.size)\n                      controller.close();\n                  });\n                }\n              });\n            }, "stream");\n          } catch (e2) {\n            try {\n              new Response("").body.getReader().read();\n              stream = /* @__PURE__ */ __name(function stream2() {\n                return new Response(this).body;\n              }, "stream");\n            } catch (e3) {\n              stream = /* @__PURE__ */ __name(function stream2() {\n                throw new Error("Include https://github.com/MattiasBuelens/web-streams-polyfill");\n              }, "stream");\n            }\n          }\n        }\n        function promisify(obj) {\n          return new Promise(function(resolve, reject) {\n            obj.onload = obj.onerror = function(evt) {\n              obj.onload = obj.onerror = null;\n              evt.type === "load" ? resolve(obj.result || obj) : reject(new Error("Failed to read the blob/file"));\n            };\n          });\n        }\n        __name(promisify, "promisify");\n        if (!blob.arrayBuffer) {\n          blob.arrayBuffer = /* @__PURE__ */ __name(function arrayBuffer() {\n            var fr = new FileReader();\n            fr.readAsArrayBuffer(this);\n            return promisify(fr);\n          }, "arrayBuffer");\n        }\n        if (!blob.text) {\n          blob.text = /* @__PURE__ */ __name(function text() {\n            var fr = new FileReader();\n            fr.readAsText(this);\n            return promisify(fr);\n          }, "text");\n        }\n        if (!blob.stream) {\n          blob.stream = stream;\n        }\n      });\n    })(\n      typeof self !== "undefined" && self || typeof window !== "undefined" && window || typeof global !== "undefined" && global || exports\n    );\n  }\n});\n\n// src/primitives/blob.js\nvar blob_exports = {};\n__export(blob_exports, {\n  Blob: () => import_blob_polyfill.Blob\n});\nmodule.exports = __toCommonJS(blob_exports);\ninit_define_process();\nvar import_blob_polyfill = __toESM(require_Blob());\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  Blob\n});\n'},484:e=>{e.exports='"use strict";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. "__esModule" has not been set), then set\n  // "default" to the CommonJS "module.exports" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);\n\n// <define:process>\nvar init_define_process = __esm({\n  "<define:process>"() {\n  }\n});\n\n// ../format/dist/index.js\nvar require_dist = __commonJS({\n  "../format/dist/index.js"(exports, module2) {\n    "use strict";\n    init_define_process();\n    var __defProp2 = Object.defineProperty;\n    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;\n    var __getOwnPropNames2 = Object.getOwnPropertyNames;\n    var __hasOwnProp2 = Object.prototype.hasOwnProperty;\n    var __export2 = /* @__PURE__ */ __name((target, all) => {\n      for (var name in all)\n        __defProp2(target, name, { get: all[name], enumerable: true });\n    }, "__export");\n    var __copyProps2 = /* @__PURE__ */ __name((to, from, except, desc) => {\n      if (from && typeof from === "object" || typeof from === "function") {\n        for (let key of __getOwnPropNames2(from))\n          if (!__hasOwnProp2.call(to, key) && key !== except)\n            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });\n      }\n      return to;\n    }, "__copyProps");\n    var __toCommonJS2 = /* @__PURE__ */ __name((mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod), "__toCommonJS");\n    var src_exports = {};\n    __export2(src_exports, {\n      createFormat: () => createFormat2\n    });\n    module2.exports = __toCommonJS2(src_exports);\n    var ReflectGetOwnPropertyDescriptor = Reflect.getOwnPropertyDescriptor;\n    function GetOwnGetter(target, key) {\n      const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n      return descriptor ? descriptor.get : void 0;\n    }\n    __name(GetOwnGetter, "GetOwnGetter");\n    var ReflectGetPrototypeOf = Reflect.getPrototypeOf;\n    var TypedArray = ReflectGetPrototypeOf(Uint8Array);\n    var ArrayPrototypeFilter = Array.prototype.filter;\n    var ArrayPrototypePush = Array.prototype.push;\n    var DatePrototypeGetTime = Date.prototype.getTime;\n    var DatePrototypeToISOString = Date.prototype.toISOString;\n    var ObjectGetOwnPropertyDescriptors = Object.getOwnPropertyDescriptors;\n    var ObjectGetOwnPropertyNames = Object.getOwnPropertyNames;\n    var ObjectGetOwnPropertySymbols = Object.getOwnPropertySymbols;\n    var ObjectKeys = Object.keys;\n    var ObjectPrototypePropertyIsEnumerable = Object.prototype.propertyIsEnumerable;\n    var ObjectPrototypeToString = Object.prototype.toString;\n    var MapPrototypeGetSize = GetOwnGetter(Map.prototype, "size");\n    var SetPrototypeGetSize = GetOwnGetter(Set.prototype, "size");\n    var StringPrototypeIncludes = String.prototype.includes;\n    var SymbolIterator = Symbol.iterator;\n    var SymbolPrototypeToString = Symbol.prototype.toString;\n    var TypedArrayPrototypeGetLength = GetOwnGetter(\n      TypedArray.prototype,\n      "length"\n    );\n    var typedArrayStrings = /* @__PURE__ */ new Set([\n      "[object BigInt64Array]",\n      "[object BigUint64Array]",\n      "[object Float32Array]",\n      "[object Float64Array]",\n      "[object Int8Array]",\n      "[object Int16Array]",\n      "[object Int32Array]",\n      "[object Uint8Array]",\n      "[object Uint8ClampedArray]",\n      "[object Uint16Array]",\n      "[object Uint32Array]"\n    ]);\n    function getOwnNonIndexProperties(object, filter) {\n      const indexes = Array.isArray(object) || isTypedArray(object) ? new Set([...object.keys()].map((v) => v.toString())) : void 0;\n      return Object.entries(ObjectGetOwnPropertyDescriptors(object)).filter(([key, desc]) => {\n        if (indexes && indexes.has(key)) {\n          return false;\n        }\n        if (filter === 1 && !desc.enumerable) {\n          return false;\n        }\n        return true;\n      }).map(([key]) => key);\n    }\n    __name(getOwnNonIndexProperties, "getOwnNonIndexProperties");\n    var isTypedArray = /* @__PURE__ */ __name((value) => kind(value, "object") && typedArrayStrings.has(ObjectPrototypeToString.call(value)), "isTypedArray");\n    function kind(value, type) {\n      return typeof value === type;\n    }\n    __name(kind, "kind");\n    var getConstructorName = /* @__PURE__ */ __name((object) => {\n      var _a;\n      return (_a = object.constructor) == null ? void 0 : _a.name;\n    }, "getConstructorName");\n    var getPrefix = /* @__PURE__ */ __name((constructor = "", size = "") => `${constructor}${size} `, "getPrefix");\n    function createFormat2(opts = {}) {\n      if (opts.customInspectSymbol === void 0) {\n        opts.customInspectSymbol = Symbol.for("edge-runtime.inspect.custom");\n      }\n      if (opts.formatError === void 0) {\n        opts.formatError = (error2) => `[${Error.prototype.toString.call(error2)}]`;\n      }\n      const { formatError, customInspectSymbol } = opts;\n      function format2(...args) {\n        const [firstArg] = args;\n        if (!kind(firstArg, "string")) {\n          if (hasCustomSymbol(firstArg, customInspectSymbol)) {\n            return format2(firstArg[customInspectSymbol]({ format: format2 }));\n          } else {\n            return args.map((item) => inspect(item, { customInspectSymbol })).join(" ");\n          }\n        }\n        let index = 1;\n        let str = String(firstArg).replace(/%[sjdOoif%]/g, (token) => {\n          if (token === "%%")\n            return "%";\n          if (index >= args.length)\n            return token;\n          switch (token) {\n            case "%s": {\n              const arg = args[index++];\n              if (hasCustomSymbol(arg, customInspectSymbol)) {\n                return format2(arg[customInspectSymbol]({ format: format2 }));\n              } else if (isDate(arg) || isError(arg) || kind(arg, "bigint")) {\n                return format2(arg);\n              } else {\n                return String(arg);\n              }\n            }\n            case "%j":\n              return safeStringify(args[index++]);\n            case "%d": {\n              const arg = args[index++];\n              if (kind(arg, "bigint")) {\n                return format2(arg);\n              } else {\n                return String(Number(arg));\n              }\n            }\n            case "%O":\n              return inspect(args[index++], { customInspectSymbol });\n            case "%o":\n              return inspect(args[index++], {\n                customInspectSymbol,\n                showHidden: true,\n                depth: 4\n              });\n            case "%i": {\n              const arg = args[index++];\n              if (kind(arg, "bigint")) {\n                return format2(arg);\n              } else {\n                return String(parseInt(arg, 10));\n              }\n            }\n            case "%f":\n              return String(parseFloat(args[index++]));\n            default:\n              return token;\n          }\n        });\n        for (let arg = args[index]; index < args.length; arg = args[++index]) {\n          if (arg === null || !kind(arg, "object")) {\n            str += " " + arg;\n          } else {\n            str += " " + inspect(arg);\n          }\n        }\n        return str;\n      }\n      __name(format2, "format");\n      function formatValue(ctx, value, recurseTimes) {\n        if (hasCustomSymbol(value, customInspectSymbol)) {\n          return format2(value[customInspectSymbol]({ format: format2 }));\n        }\n        const formattedPrimitive = formatPrimitive(value);\n        if (formattedPrimitive !== void 0) {\n          return formattedPrimitive;\n        }\n        if (ctx.seen.includes(value)) {\n          let index = 1;\n          if (ctx.circular === void 0) {\n            ctx.circular = /* @__PURE__ */ new Map();\n            ctx.circular.set(value, index);\n          } else {\n            index = ctx.circular.get(value);\n            if (index === void 0) {\n              index = ctx.circular.size + 1;\n              ctx.circular.set(value, index);\n            }\n          }\n          return `[Circular *${index}]`;\n        }\n        return formatRaw(ctx, value, recurseTimes);\n      }\n      __name(formatValue, "formatValue");\n      function formatRaw(ctx, value, recurseTimes) {\n        let keys = [];\n        const constructor = getConstructorName(value);\n        let base = "";\n        let formatter = /* @__PURE__ */ __name(() => [], "formatter");\n        let braces = ["", ""];\n        let noIterator = true;\n        const filter = ctx.showHidden ? 0 : 1;\n        if (SymbolIterator in value) {\n          noIterator = false;\n          if (Array.isArray(value)) {\n            const prefix = constructor !== "Array" ? getPrefix(constructor, `(${value.length})`) : "";\n            keys = getOwnNonIndexProperties(value, filter);\n            braces = [`${prefix}[`, "]"];\n            if (value.length === 0 && keys.length === 0) {\n              return `${braces[0]}]`;\n            }\n            formatter = formatArray;\n          } else if (isSet(value)) {\n            const size = SetPrototypeGetSize.call(value);\n            const prefix = getPrefix(constructor, `(${size})`);\n            keys = getKeys(value, ctx.showHidden);\n            formatter = formatSet;\n            if (size === 0 && keys.length === 0) {\n              return `${prefix}{}`;\n            }\n            braces = [`${prefix}{`, "}"];\n          } else if (isMap(value)) {\n            const size = MapPrototypeGetSize.call(value);\n            const prefix = getPrefix(constructor, `(${size})`);\n            keys = getKeys(value, ctx.showHidden);\n            formatter = formatMap;\n            if (size === 0 && keys.length === 0) {\n              return `${prefix}{}`;\n            }\n            braces = [`${prefix}{`, "}"];\n          } else if (isTypedArray(value)) {\n            keys = getOwnNonIndexProperties(value, filter);\n            const size = TypedArrayPrototypeGetLength.call(value);\n            const prefix = getPrefix(constructor, `(${size})`);\n            braces = [`${prefix}[`, "]"];\n            if (value.length === 0 && keys.length === 0)\n              return `${braces[0]}]`;\n            formatter = formatTypedArray.bind(null, size);\n          } else {\n            noIterator = true;\n          }\n        }\n        if (noIterator) {\n          keys = getKeys(value, ctx.showHidden);\n          braces = ["{", "}"];\n          if (constructor === void 0) {\n            if (keys.length === 0) {\n              return `[Object: null prototype] {}`;\n            }\n          } else if (constructor === "Object") {\n            if (keys.length === 0) {\n              return `{}`;\n            }\n          } else if (kind(value, "function")) {\n            base = `[Function${value.name ? ": " + value.name : ""}]`;\n            if (keys.length === 0) {\n              return base;\n            }\n          } else if (isRegExp(value)) {\n            base = RegExp.prototype.toString.call(value);\n            if (keys.length === 0) {\n              return base;\n            }\n            base = " " + base;\n          } else if (isDate(value)) {\n            base = Number.isNaN(DatePrototypeGetTime.call(value)) ? Date.prototype.toString.call(value) : DatePrototypeToISOString.call(value);\n            if (keys.length === 0) {\n              return base;\n            }\n            base = " " + base;\n          } else if (isError(value)) {\n            base = formatError(value);\n            if (keys.length === 0) {\n              return base;\n            }\n            base = " " + base;\n          } else if (hasCustomSymbol(value, ctx.customInspectSymbol)) {\n            base = format2(value[ctx.customInspectSymbol]({ format: format2 }));\n            if (keys.length === 0) {\n              return base;\n            }\n            base = " " + base;\n          } else {\n            braces[0] = `${getPrefix(constructor)}{`;\n          }\n        }\n        if (recurseTimes && recurseTimes < 0) {\n          return isRegExp(value) ? RegExp.prototype.toString.call(value) : "[Object]";\n        }\n        ctx.seen.push(value);\n        const visibleKeys = new Set(keys);\n        const output = formatter(ctx, value, recurseTimes, visibleKeys, keys);\n        for (let i = 0; i < keys.length; i++) {\n          output.push(\n            formatProperty(\n              ctx,\n              value,\n              recurseTimes,\n              visibleKeys,\n              keys[i],\n              false\n            )\n          );\n        }\n        if (ctx.circular !== void 0) {\n          const index = ctx.circular.get(value);\n          if (index !== void 0) {\n            const reference = `<ref *${index}>`;\n            base = base === "" ? reference : `${reference} ${base}`;\n          }\n        }\n        ctx.seen.pop();\n        return reduceToSingleString(output, base, braces);\n      }\n      __name(formatRaw, "formatRaw");\n      function inspect(value, opts2) {\n        opts2 = Object.assign({ seen: [], depth: 2 }, opts2);\n        return formatValue(opts2, value, opts2.depth);\n      }\n      __name(inspect, "inspect");\n      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, isArray) {\n        let name;\n        let str;\n        const desc = Object.getOwnPropertyDescriptor(value, key) || {\n          value: value[key]\n        };\n        if (desc.value !== void 0) {\n          str = formatValue(ctx, desc.value, recurseTimes);\n        } else if (desc.get) {\n          str = desc.set ? "[Getter/Setter]" : "[Getter]";\n        } else if (desc.set) {\n          str = "[Setter]";\n        } else {\n          str = "undefined";\n        }\n        if (isArray) {\n          return str;\n        }\n        if (kind(key, "symbol")) {\n          name = `[${SymbolPrototypeToString.call(key)}]`;\n        } else if (!visibleKeys.has(key)) {\n          name = "[" + key + "]";\n        } else {\n          name = key;\n        }\n        return `${name}: ${str}`;\n      }\n      __name(formatProperty, "formatProperty");\n      function formatArray(ctx, value, recurseTimes, visibleKeys) {\n        const output = [];\n        for (let index = 0; index < value.length; ++index) {\n          if (Object.prototype.hasOwnProperty.call(value, String(index))) {\n            output.push(\n              formatProperty(\n                ctx,\n                value,\n                recurseTimes,\n                visibleKeys,\n                String(index),\n                true\n              )\n            );\n          } else {\n            output.push("");\n          }\n        }\n        return output;\n      }\n      __name(formatArray, "formatArray");\n      function formatTypedArray(length, ctx, value, recurseTimes) {\n        const output = new Array(length);\n        for (let i = 0; i < length; ++i) {\n          output[i] = value.length > 0 && kind(value[0], "number") ? String(value[i]) : formatBigInt(value[i]);\n        }\n        if (ctx.showHidden) {\n          for (const key of [\n            "BYTES_PER_ELEMENT",\n            "length",\n            "byteLength",\n            "byteOffset",\n            "buffer"\n          ]) {\n            const str = formatValue(ctx, value[key], recurseTimes);\n            ArrayPrototypePush.call(output, `[${String(key)}]: ${str}`);\n          }\n        }\n        return output;\n      }\n      __name(formatTypedArray, "formatTypedArray");\n      function formatSet(ctx, value, recurseTimes) {\n        const output = [];\n        for (const v of value) {\n          ArrayPrototypePush.call(output, formatValue(ctx, v, recurseTimes));\n        }\n        return output;\n      }\n      __name(formatSet, "formatSet");\n      function formatMap(ctx, value, recurseTimes) {\n        const output = [];\n        for (const { 0: k, 1: v } of value) {\n          output.push(\n            `${formatValue(ctx, k, recurseTimes)} => ${formatValue(\n              ctx,\n              v,\n              recurseTimes\n            )}`\n          );\n        }\n        return output;\n      }\n      __name(formatMap, "formatMap");\n      return format2;\n    }\n    __name(createFormat2, "createFormat");\n    var formatBigInt = /* @__PURE__ */ __name((bigint) => `${bigint}n`, "formatBigInt");\n    function formatPrimitive(value) {\n      if (value === null)\n        return "null";\n      if (value === void 0)\n        return "undefined";\n      if (kind(value, "string")) {\n        return `\'${JSON.stringify(value).replace(/^"|"$/g, "").replace(/\'/g, "\\\\\'").replace(/\\\\"/g, \'"\')}\'`;\n      }\n      if (kind(value, "boolean"))\n        return "" + value;\n      if (kind(value, "number"))\n        return "" + value;\n      if (kind(value, "bigint"))\n        return formatBigInt(value);\n      if (kind(value, "symbol"))\n        return value.toString();\n    }\n    __name(formatPrimitive, "formatPrimitive");\n    function hasCustomSymbol(value, customInspectSymbol) {\n      return value !== null && kind(value, "object") && customInspectSymbol in value && kind(value[customInspectSymbol], "function");\n    }\n    __name(hasCustomSymbol, "hasCustomSymbol");\n    function isRegExp(value) {\n      return kind(value, "object") && Object.prototype.toString.call(value) === "[object RegExp]";\n    }\n    __name(isRegExp, "isRegExp");\n    function isDate(value) {\n      return kind(value, "object") && Object.prototype.toString.call(value) === "[object Date]";\n    }\n    __name(isDate, "isDate");\n    function isError(value) {\n      return kind(value, "object") && (Object.prototype.toString.call(value) === "[object Error]" || value instanceof Error);\n    }\n    __name(isError, "isError");\n    function isMap(value) {\n      return kind(value, "object") && Object.prototype.toString.call(value) === "[object Map]";\n    }\n    __name(isMap, "isMap");\n    function isSet(value) {\n      return kind(value, "object") && Object.prototype.toString.call(value) === "[object Set]";\n    }\n    __name(isSet, "isSet");\n    function isBelowBreakLength(output, start, base) {\n      const breakLength = 80;\n      let totalLength = output.length + start;\n      if (totalLength + output.length > breakLength) {\n        return false;\n      }\n      for (let i = 0; i < output.length; i++) {\n        totalLength += output[i].length;\n        if (totalLength > breakLength) {\n          return false;\n        }\n      }\n      return base === "" || !StringPrototypeIncludes.call(base, "\\n");\n    }\n    __name(isBelowBreakLength, "isBelowBreakLength");\n    function reduceToSingleString(output, base, braces) {\n      const start = output.length + braces[0].length + base.length + 10;\n      if (!isBelowBreakLength(output, start, base)) {\n        return (base ? base + " " : "") + braces[0] + "\\n  " + output.join(",\\n  ") + "\\n" + braces[1];\n      }\n      return ((base ? base + " " : "") + braces[0] + " " + output.join(", ") + " " + braces[1]).trim();\n    }\n    __name(reduceToSingleString, "reduceToSingleString");\n    function safeStringify(input) {\n      if (Array.isArray(input)) {\n        input = input.map(\n          (element) => JSON.parse(JSON.stringify(element, makeCircularReplacer()))\n        );\n      }\n      return JSON.stringify(input, makeCircularReplacer());\n    }\n    __name(safeStringify, "safeStringify");\n    function makeCircularReplacer() {\n      const seen = /* @__PURE__ */ new WeakSet();\n      return (key, value) => {\n        if (value !== null && kind(value, "object")) {\n          if (seen.has(value))\n            return "[Circular]";\n          seen.add(value);\n        }\n        return value;\n      };\n    }\n    __name(makeCircularReplacer, "makeCircularReplacer");\n    function getKeys(value, showHidden = false) {\n      let keys;\n      const symbols = ObjectGetOwnPropertySymbols(value);\n      if (showHidden) {\n        keys = ObjectGetOwnPropertyNames(value);\n        if (symbols.length !== 0)\n          ArrayPrototypePush.apply(keys, symbols);\n      } else {\n        try {\n          keys = ObjectKeys(value);\n        } catch (err) {\n          keys = ObjectGetOwnPropertyNames(value);\n        }\n        if (symbols.length !== 0) {\n          const filter = /* @__PURE__ */ __name((key) => ObjectPrototypePropertyIsEnumerable.call(value, key), "filter");\n          ArrayPrototypePush.apply(keys, ArrayPrototypeFilter.call(symbols, filter));\n        }\n      }\n      return keys;\n    }\n    __name(getKeys, "getKeys");\n  }\n});\n\n// src/primitives/console.js\nvar console_exports = {};\n__export(console_exports, {\n  console: () => konsole\n});\nmodule.exports = __toCommonJS(console_exports);\ninit_define_process();\nvar import_format = __toESM(require_dist());\nvar format = (0, import_format.createFormat)();\nvar bareError = console.error.bind(console);\nvar bareLog = console.log.bind(console);\nvar assert = console.assert.bind(console);\nvar time = console.time.bind(console);\nvar timeEnd = console.timeEnd.bind(console);\nvar timeLog = console.timeLog.bind(console);\nvar trace = console.trace.bind(console);\nvar error = /* @__PURE__ */ __name((...args) => bareError(format(...args)), "error");\nvar log = /* @__PURE__ */ __name((...args) => bareLog(format(...args)), "log");\nvar konsole = {\n  assert: (assertion, ...args) => assert(assertion, format(...args)),\n  count: console.count.bind(console),\n  debug: log,\n  dir: console.dir.bind(console),\n  error,\n  info: log,\n  log,\n  time: (...args) => time(format(...args)),\n  timeEnd: (...args) => timeEnd(format(...args)),\n  timeLog,\n  trace,\n  warn: error\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  console\n});\n'},446:e=>{e.exports='"use strict";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. "__esModule" has not been set), then set\n  // "default" to the CommonJS "module.exports" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);\n\n// src/primitives/crypto.js\nvar crypto_exports = {};\n__export(crypto_exports, {\n  Crypto: () => Crypto2,\n  CryptoKey: () => CryptoKey,\n  SubtleCrypto: () => SubtleCrypto3,\n  crypto: () => crypto2\n});\nmodule.exports = __toCommonJS(crypto_exports);\n\n// ../../node_modules/.pnpm/pvtsutils@1.3.2/node_modules/pvtsutils/build/index.es.js\nvar ARRAY_BUFFER_NAME = "[object ArrayBuffer]";\nvar BufferSourceConverter = class {\n  static isArrayBuffer(data) {\n    return Object.prototype.toString.call(data) === ARRAY_BUFFER_NAME;\n  }\n  static toArrayBuffer(data) {\n    if (this.isArrayBuffer(data)) {\n      return data;\n    }\n    if (data.byteLength === data.buffer.byteLength) {\n      return data.buffer;\n    }\n    return this.toUint8Array(data).slice().buffer;\n  }\n  static toUint8Array(data) {\n    return this.toView(data, Uint8Array);\n  }\n  static toView(data, type) {\n    if (data.constructor === type) {\n      return data;\n    }\n    if (this.isArrayBuffer(data)) {\n      return new type(data);\n    }\n    if (this.isArrayBufferView(data)) {\n      return new type(data.buffer, data.byteOffset, data.byteLength);\n    }\n    throw new TypeError("The provided value is not of type \'(ArrayBuffer or ArrayBufferView)\'");\n  }\n  static isBufferSource(data) {\n    return this.isArrayBufferView(data) || this.isArrayBuffer(data);\n  }\n  static isArrayBufferView(data) {\n    return ArrayBuffer.isView(data) || data && this.isArrayBuffer(data.buffer);\n  }\n  static isEqual(a, b) {\n    const aView = BufferSourceConverter.toUint8Array(a);\n    const bView = BufferSourceConverter.toUint8Array(b);\n    if (aView.length !== bView.byteLength) {\n      return false;\n    }\n    for (let i = 0; i < aView.length; i++) {\n      if (aView[i] !== bView[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static concat(...args) {\n    if (Array.isArray(args[0])) {\n      const buffers = args[0];\n      let size = 0;\n      for (const buffer of buffers) {\n        size += buffer.byteLength;\n      }\n      const res = new Uint8Array(size);\n      let offset = 0;\n      for (const buffer of buffers) {\n        const view = this.toUint8Array(buffer);\n        res.set(view, offset);\n        offset += view.length;\n      }\n      if (args[1]) {\n        return this.toView(res, args[1]);\n      }\n      return res.buffer;\n    } else {\n      return this.concat(args);\n    }\n  }\n};\n__name(BufferSourceConverter, "BufferSourceConverter");\nvar Utf8Converter = class {\n  static fromString(text) {\n    const s = unescape(encodeURIComponent(text));\n    const uintArray = new Uint8Array(s.length);\n    for (let i = 0; i < s.length; i++) {\n      uintArray[i] = s.charCodeAt(i);\n    }\n    return uintArray.buffer;\n  }\n  static toString(buffer) {\n    const buf = BufferSourceConverter.toUint8Array(buffer);\n    let encodedString = "";\n    for (let i = 0; i < buf.length; i++) {\n      encodedString += String.fromCharCode(buf[i]);\n    }\n    const decodedString = decodeURIComponent(escape(encodedString));\n    return decodedString;\n  }\n};\n__name(Utf8Converter, "Utf8Converter");\nvar Utf16Converter = class {\n  static toString(buffer, littleEndian = false) {\n    const arrayBuffer = BufferSourceConverter.toArrayBuffer(buffer);\n    const dataView = new DataView(arrayBuffer);\n    let res = "";\n    for (let i = 0; i < arrayBuffer.byteLength; i += 2) {\n      const code = dataView.getUint16(i, littleEndian);\n      res += String.fromCharCode(code);\n    }\n    return res;\n  }\n  static fromString(text, littleEndian = false) {\n    const res = new ArrayBuffer(text.length * 2);\n    const dataView = new DataView(res);\n    for (let i = 0; i < text.length; i++) {\n      dataView.setUint16(i * 2, text.charCodeAt(i), littleEndian);\n    }\n    return res;\n  }\n};\n__name(Utf16Converter, "Utf16Converter");\nvar Convert = class {\n  static isHex(data) {\n    return typeof data === "string" && /^[a-z0-9]+$/i.test(data);\n  }\n  static isBase64(data) {\n    return typeof data === "string" && /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(data);\n  }\n  static isBase64Url(data) {\n    return typeof data === "string" && /^[a-zA-Z0-9-_]+$/i.test(data);\n  }\n  static ToString(buffer, enc = "utf8") {\n    const buf = BufferSourceConverter.toUint8Array(buffer);\n    switch (enc.toLowerCase()) {\n      case "utf8":\n        return this.ToUtf8String(buf);\n      case "binary":\n        return this.ToBinary(buf);\n      case "hex":\n        return this.ToHex(buf);\n      case "base64":\n        return this.ToBase64(buf);\n      case "base64url":\n        return this.ToBase64Url(buf);\n      case "utf16le":\n        return Utf16Converter.toString(buf, true);\n      case "utf16":\n      case "utf16be":\n        return Utf16Converter.toString(buf);\n      default:\n        throw new Error(`Unknown type of encoding \'${enc}\'`);\n    }\n  }\n  static FromString(str, enc = "utf8") {\n    if (!str) {\n      return new ArrayBuffer(0);\n    }\n    switch (enc.toLowerCase()) {\n      case "utf8":\n        return this.FromUtf8String(str);\n      case "binary":\n        return this.FromBinary(str);\n      case "hex":\n        return this.FromHex(str);\n      case "base64":\n        return this.FromBase64(str);\n      case "base64url":\n        return this.FromBase64Url(str);\n      case "utf16le":\n        return Utf16Converter.fromString(str, true);\n      case "utf16":\n      case "utf16be":\n        return Utf16Converter.fromString(str);\n      default:\n        throw new Error(`Unknown type of encoding \'${enc}\'`);\n    }\n  }\n  static ToBase64(buffer) {\n    const buf = BufferSourceConverter.toUint8Array(buffer);\n    if (typeof btoa !== "undefined") {\n      const binary = this.ToString(buf, "binary");\n      return btoa(binary);\n    } else {\n      return Buffer.from(buf).toString("base64");\n    }\n  }\n  static FromBase64(base64) {\n    const formatted = this.formatString(base64);\n    if (!formatted) {\n      return new ArrayBuffer(0);\n    }\n    if (!Convert.isBase64(formatted)) {\n      throw new TypeError("Argument \'base64Text\' is not Base64 encoded");\n    }\n    if (typeof atob !== "undefined") {\n      return this.FromBinary(atob(formatted));\n    } else {\n      return new Uint8Array(Buffer.from(formatted, "base64")).buffer;\n    }\n  }\n  static FromBase64Url(base64url) {\n    const formatted = this.formatString(base64url);\n    if (!formatted) {\n      return new ArrayBuffer(0);\n    }\n    if (!Convert.isBase64Url(formatted)) {\n      throw new TypeError("Argument \'base64url\' is not Base64Url encoded");\n    }\n    return this.FromBase64(this.Base64Padding(formatted.replace(/\\-/g, "+").replace(/\\_/g, "/")));\n  }\n  static ToBase64Url(data) {\n    return this.ToBase64(data).replace(/\\+/g, "-").replace(/\\//g, "_").replace(/\\=/g, "");\n  }\n  static FromUtf8String(text, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n    switch (encoding) {\n      case "ascii":\n        return this.FromBinary(text);\n      case "utf8":\n        return Utf8Converter.fromString(text);\n      case "utf16":\n      case "utf16be":\n        return Utf16Converter.fromString(text);\n      case "utf16le":\n      case "usc2":\n        return Utf16Converter.fromString(text, true);\n      default:\n        throw new Error(`Unknown type of encoding \'${encoding}\'`);\n    }\n  }\n  static ToUtf8String(buffer, encoding = Convert.DEFAULT_UTF8_ENCODING) {\n    switch (encoding) {\n      case "ascii":\n        return this.ToBinary(buffer);\n      case "utf8":\n        return Utf8Converter.toString(buffer);\n      case "utf16":\n      case "utf16be":\n        return Utf16Converter.toString(buffer);\n      case "utf16le":\n      case "usc2":\n        return Utf16Converter.toString(buffer, true);\n      default:\n        throw new Error(`Unknown type of encoding \'${encoding}\'`);\n    }\n  }\n  static FromBinary(text) {\n    const stringLength = text.length;\n    const resultView = new Uint8Array(stringLength);\n    for (let i = 0; i < stringLength; i++) {\n      resultView[i] = text.charCodeAt(i);\n    }\n    return resultView.buffer;\n  }\n  static ToBinary(buffer) {\n    const buf = BufferSourceConverter.toUint8Array(buffer);\n    let res = "";\n    for (let i = 0; i < buf.length; i++) {\n      res += String.fromCharCode(buf[i]);\n    }\n    return res;\n  }\n  static ToHex(buffer) {\n    const buf = BufferSourceConverter.toUint8Array(buffer);\n    const splitter = "";\n    const res = [];\n    const len = buf.length;\n    for (let i = 0; i < len; i++) {\n      const char = buf[i].toString(16).padStart(2, "0");\n      res.push(char);\n    }\n    return res.join(splitter);\n  }\n  static FromHex(hexString) {\n    let formatted = this.formatString(hexString);\n    if (!formatted) {\n      return new ArrayBuffer(0);\n    }\n    if (!Convert.isHex(formatted)) {\n      throw new TypeError("Argument \'hexString\' is not HEX encoded");\n    }\n    if (formatted.length % 2) {\n      formatted = `0${formatted}`;\n    }\n    const res = new Uint8Array(formatted.length / 2);\n    for (let i = 0; i < formatted.length; i = i + 2) {\n      const c = formatted.slice(i, i + 2);\n      res[i / 2] = parseInt(c, 16);\n    }\n    return res.buffer;\n  }\n  static ToUtf16String(buffer, littleEndian = false) {\n    return Utf16Converter.toString(buffer, littleEndian);\n  }\n  static FromUtf16String(text, littleEndian = false) {\n    return Utf16Converter.fromString(text, littleEndian);\n  }\n  static Base64Padding(base64) {\n    const padCount = 4 - base64.length % 4;\n    if (padCount < 4) {\n      for (let i = 0; i < padCount; i++) {\n        base64 += "=";\n      }\n    }\n    return base64;\n  }\n  static formatString(data) {\n    return (data === null || data === void 0 ? void 0 : data.replace(/[\\n\\r\\t ]/g, "")) || "";\n  }\n};\n__name(Convert, "Convert");\nConvert.DEFAULT_UTF8_ENCODING = "utf8";\nfunction combine(...buf) {\n  const totalByteLength = buf.map((item) => item.byteLength).reduce((prev, cur) => prev + cur);\n  const res = new Uint8Array(totalByteLength);\n  let currentPos = 0;\n  buf.map((item) => new Uint8Array(item)).forEach((arr) => {\n    for (const item2 of arr) {\n      res[currentPos++] = item2;\n    }\n  });\n  return res.buffer;\n}\n__name(combine, "combine");\n\n// ../../node_modules/.pnpm/asn1js@3.0.5/node_modules/asn1js/build/index.es.js\nvar index_es_exports = {};\n__export(index_es_exports, {\n  Any: () => Any,\n  BaseBlock: () => BaseBlock,\n  BaseStringBlock: () => BaseStringBlock,\n  BitString: () => BitString,\n  BmpString: () => BmpString,\n  Boolean: () => Boolean,\n  CharacterString: () => CharacterString,\n  Choice: () => Choice,\n  Constructed: () => Constructed,\n  DATE: () => DATE,\n  DateTime: () => DateTime,\n  Duration: () => Duration,\n  EndOfContent: () => EndOfContent,\n  Enumerated: () => Enumerated,\n  GeneralString: () => GeneralString,\n  GeneralizedTime: () => GeneralizedTime,\n  GraphicString: () => GraphicString,\n  HexBlock: () => HexBlock,\n  IA5String: () => IA5String,\n  Integer: () => Integer,\n  Null: () => Null,\n  NumericString: () => NumericString,\n  ObjectIdentifier: () => ObjectIdentifier,\n  OctetString: () => OctetString,\n  Primitive: () => Primitive,\n  PrintableString: () => PrintableString,\n  RawData: () => RawData,\n  RelativeObjectIdentifier: () => RelativeObjectIdentifier,\n  Repeated: () => Repeated,\n  Sequence: () => Sequence,\n  Set: () => Set,\n  TIME: () => TIME,\n  TeletexString: () => TeletexString,\n  TimeOfDay: () => TimeOfDay,\n  UTCTime: () => UTCTime,\n  UniversalString: () => UniversalString,\n  Utf8String: () => Utf8String,\n  ValueBlock: () => ValueBlock,\n  VideotexString: () => VideotexString,\n  ViewWriter: () => ViewWriter,\n  VisibleString: () => VisibleString,\n  compareSchema: () => compareSchema,\n  fromBER: () => fromBER,\n  verifySchema: () => verifySchema\n});\n\n// ../../node_modules/.pnpm/pvutils@1.1.3/node_modules/pvutils/build/utils.es.js\nfunction utilFromBase(inputBuffer, inputBase) {\n  let result = 0;\n  if (inputBuffer.length === 1) {\n    return inputBuffer[0];\n  }\n  for (let i = inputBuffer.length - 1; i >= 0; i--) {\n    result += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);\n  }\n  return result;\n}\n__name(utilFromBase, "utilFromBase");\nfunction utilToBase(value, base, reserved = -1) {\n  const internalReserved = reserved;\n  let internalValue = value;\n  let result = 0;\n  let biggest = Math.pow(2, base);\n  for (let i = 1; i < 8; i++) {\n    if (value < biggest) {\n      let retBuf;\n      if (internalReserved < 0) {\n        retBuf = new ArrayBuffer(i);\n        result = i;\n      } else {\n        if (internalReserved < i) {\n          return new ArrayBuffer(0);\n        }\n        retBuf = new ArrayBuffer(internalReserved);\n        result = internalReserved;\n      }\n      const retView = new Uint8Array(retBuf);\n      for (let j = i - 1; j >= 0; j--) {\n        const basis = Math.pow(2, j * base);\n        retView[result - j - 1] = Math.floor(internalValue / basis);\n        internalValue -= retView[result - j - 1] * basis;\n      }\n      return retBuf;\n    }\n    biggest *= Math.pow(2, base);\n  }\n  return new ArrayBuffer(0);\n}\n__name(utilToBase, "utilToBase");\nfunction utilConcatView(...views) {\n  let outputLength = 0;\n  let prevLength = 0;\n  for (const view of views) {\n    outputLength += view.length;\n  }\n  const retBuf = new ArrayBuffer(outputLength);\n  const retView = new Uint8Array(retBuf);\n  for (const view of views) {\n    retView.set(view, prevLength);\n    prevLength += view.length;\n  }\n  return retView;\n}\n__name(utilConcatView, "utilConcatView");\nfunction utilDecodeTC() {\n  const buf = new Uint8Array(this.valueHex);\n  if (this.valueHex.byteLength >= 2) {\n    const condition1 = buf[0] === 255 && buf[1] & 128;\n    const condition2 = buf[0] === 0 && (buf[1] & 128) === 0;\n    if (condition1 || condition2) {\n      this.warnings.push("Needlessly long format");\n    }\n  }\n  const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\n  const bigIntView = new Uint8Array(bigIntBuffer);\n  for (let i = 0; i < this.valueHex.byteLength; i++) {\n    bigIntView[i] = 0;\n  }\n  bigIntView[0] = buf[0] & 128;\n  const bigInt = utilFromBase(bigIntView, 8);\n  const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\n  const smallIntView = new Uint8Array(smallIntBuffer);\n  for (let j = 0; j < this.valueHex.byteLength; j++) {\n    smallIntView[j] = buf[j];\n  }\n  smallIntView[0] &= 127;\n  const smallInt = utilFromBase(smallIntView, 8);\n  return smallInt - bigInt;\n}\n__name(utilDecodeTC, "utilDecodeTC");\nfunction utilEncodeTC(value) {\n  const modValue = value < 0 ? value * -1 : value;\n  let bigInt = 128;\n  for (let i = 1; i < 8; i++) {\n    if (modValue <= bigInt) {\n      if (value < 0) {\n        const smallInt = bigInt - modValue;\n        const retBuf2 = utilToBase(smallInt, 8, i);\n        const retView2 = new Uint8Array(retBuf2);\n        retView2[0] |= 128;\n        return retBuf2;\n      }\n      let retBuf = utilToBase(modValue, 8, i);\n      let retView = new Uint8Array(retBuf);\n      if (retView[0] & 128) {\n        const tempBuf = retBuf.slice(0);\n        const tempView = new Uint8Array(tempBuf);\n        retBuf = new ArrayBuffer(retBuf.byteLength + 1);\n        retView = new Uint8Array(retBuf);\n        for (let k = 0; k < tempBuf.byteLength; k++) {\n          retView[k + 1] = tempView[k];\n        }\n        retView[0] = 0;\n      }\n      return retBuf;\n    }\n    bigInt *= Math.pow(2, 8);\n  }\n  return new ArrayBuffer(0);\n}\n__name(utilEncodeTC, "utilEncodeTC");\nfunction isEqualBuffer(inputBuffer1, inputBuffer2) {\n  if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {\n    return false;\n  }\n  const view1 = new Uint8Array(inputBuffer1);\n  const view2 = new Uint8Array(inputBuffer2);\n  for (let i = 0; i < view1.length; i++) {\n    if (view1[i] !== view2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n__name(isEqualBuffer, "isEqualBuffer");\nfunction padNumber(inputNumber, fullLength) {\n  const str = inputNumber.toString(10);\n  if (fullLength < str.length) {\n    return "";\n  }\n  const dif = fullLength - str.length;\n  const padding = new Array(dif);\n  for (let i = 0; i < dif; i++) {\n    padding[i] = "0";\n  }\n  const paddingString = padding.join("");\n  return paddingString.concat(str);\n}\n__name(padNumber, "padNumber");\nvar log2 = Math.log(2);\n\n// ../../node_modules/.pnpm/asn1js@3.0.5/node_modules/asn1js/build/index.es.js\nfunction assertBigInt() {\n  if (typeof BigInt === "undefined") {\n    throw new Error("BigInt is not defined. Your environment doesn\'t implement BigInt.");\n  }\n}\n__name(assertBigInt, "assertBigInt");\nfunction concat(buffers) {\n  let outputLength = 0;\n  let prevLength = 0;\n  for (let i = 0; i < buffers.length; i++) {\n    const buffer = buffers[i];\n    outputLength += buffer.byteLength;\n  }\n  const retView = new Uint8Array(outputLength);\n  for (let i = 0; i < buffers.length; i++) {\n    const buffer = buffers[i];\n    retView.set(new Uint8Array(buffer), prevLength);\n    prevLength += buffer.byteLength;\n  }\n  return retView.buffer;\n}\n__name(concat, "concat");\nfunction checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {\n  if (!(inputBuffer instanceof Uint8Array)) {\n    baseBlock.error = "Wrong parameter: inputBuffer must be \'Uint8Array\'";\n    return false;\n  }\n  if (!inputBuffer.byteLength) {\n    baseBlock.error = "Wrong parameter: inputBuffer has zero length";\n    return false;\n  }\n  if (inputOffset < 0) {\n    baseBlock.error = "Wrong parameter: inputOffset less than zero";\n    return false;\n  }\n  if (inputLength < 0) {\n    baseBlock.error = "Wrong parameter: inputLength less than zero";\n    return false;\n  }\n  if (inputBuffer.byteLength - inputOffset - inputLength < 0) {\n    baseBlock.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";\n    return false;\n  }\n  return true;\n}\n__name(checkBufferParams, "checkBufferParams");\nvar ViewWriter = class {\n  constructor() {\n    this.items = [];\n  }\n  write(buf) {\n    this.items.push(buf);\n  }\n  final() {\n    return concat(this.items);\n  }\n};\n__name(ViewWriter, "ViewWriter");\nvar powers2 = [new Uint8Array([1])];\nvar digitsString = "0123456789";\nvar NAME = "name";\nvar VALUE_HEX_VIEW = "valueHexView";\nvar IS_HEX_ONLY = "isHexOnly";\nvar ID_BLOCK = "idBlock";\nvar TAG_CLASS = "tagClass";\nvar TAG_NUMBER = "tagNumber";\nvar IS_CONSTRUCTED = "isConstructed";\nvar FROM_BER = "fromBER";\nvar TO_BER = "toBER";\nvar LOCAL = "local";\nvar EMPTY_STRING = "";\nvar EMPTY_BUFFER = new ArrayBuffer(0);\nvar EMPTY_VIEW = new Uint8Array(0);\nvar END_OF_CONTENT_NAME = "EndOfContent";\nvar OCTET_STRING_NAME = "OCTET STRING";\nvar BIT_STRING_NAME = "BIT STRING";\nfunction HexBlock(BaseClass) {\n  var _a2;\n  return _a2 = /* @__PURE__ */ __name(class Some extends BaseClass {\n    constructor(...args) {\n      var _a3;\n      super(...args);\n      const params = args[0] || {};\n      this.isHexOnly = (_a3 = params.isHexOnly) !== null && _a3 !== void 0 ? _a3 : false;\n      this.valueHexView = params.valueHex ? BufferSourceConverter.toUint8Array(params.valueHex) : EMPTY_VIEW;\n    }\n    get valueHex() {\n      return this.valueHexView.slice().buffer;\n    }\n    set valueHex(value) {\n      this.valueHexView = new Uint8Array(value);\n    }\n    fromBER(inputBuffer, inputOffset, inputLength) {\n      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\n      if (!checkBufferParams(this, view, inputOffset, inputLength)) {\n        return -1;\n      }\n      const endLength = inputOffset + inputLength;\n      this.valueHexView = view.subarray(inputOffset, endLength);\n      if (!this.valueHexView.length) {\n        this.warnings.push("Zero buffer length");\n        return inputOffset;\n      }\n      this.blockLength = inputLength;\n      return endLength;\n    }\n    toBER(sizeOnly = false) {\n      if (!this.isHexOnly) {\n        this.error = "Flag \'isHexOnly\' is not set, abort";\n        return EMPTY_BUFFER;\n      }\n      if (sizeOnly) {\n        return new ArrayBuffer(this.valueHexView.byteLength);\n      }\n      return this.valueHexView.byteLength === this.valueHexView.buffer.byteLength ? this.valueHexView.buffer : this.valueHexView.slice().buffer;\n    }\n    toJSON() {\n      return {\n        ...super.toJSON(),\n        isHexOnly: this.isHexOnly,\n        valueHex: Convert.ToHex(this.valueHexView)\n      };\n    }\n  }, "Some"), _a2.NAME = "hexBlock", _a2;\n}\n__name(HexBlock, "HexBlock");\nvar LocalBaseBlock = class {\n  constructor({ blockLength = 0, error = EMPTY_STRING, warnings = [], valueBeforeDecode = EMPTY_VIEW } = {}) {\n    this.blockLength = blockLength;\n    this.error = error;\n    this.warnings = warnings;\n    this.valueBeforeDecodeView = BufferSourceConverter.toUint8Array(valueBeforeDecode);\n  }\n  static blockName() {\n    return this.NAME;\n  }\n  get valueBeforeDecode() {\n    return this.valueBeforeDecodeView.slice().buffer;\n  }\n  set valueBeforeDecode(value) {\n    this.valueBeforeDecodeView = new Uint8Array(value);\n  }\n  toJSON() {\n    return {\n      blockName: this.constructor.NAME,\n      blockLength: this.blockLength,\n      error: this.error,\n      warnings: this.warnings,\n      valueBeforeDecode: Convert.ToHex(this.valueBeforeDecodeView)\n    };\n  }\n};\n__name(LocalBaseBlock, "LocalBaseBlock");\nLocalBaseBlock.NAME = "baseBlock";\nvar ValueBlock = class extends LocalBaseBlock {\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    throw TypeError("User need to make a specific function in a class which extends \'ValueBlock\'");\n  }\n  toBER(sizeOnly, writer) {\n    throw TypeError("User need to make a specific function in a class which extends \'ValueBlock\'");\n  }\n};\n__name(ValueBlock, "ValueBlock");\nValueBlock.NAME = "valueBlock";\nvar LocalIdentificationBlock = class extends HexBlock(LocalBaseBlock) {\n  constructor({ idBlock = {} } = {}) {\n    var _a2, _b, _c, _d;\n    super();\n    if (idBlock) {\n      this.isHexOnly = (_a2 = idBlock.isHexOnly) !== null && _a2 !== void 0 ? _a2 : false;\n      this.valueHexView = idBlock.valueHex ? BufferSourceConverter.toUint8Array(idBlock.valueHex) : EMPTY_VIEW;\n      this.tagClass = (_b = idBlock.tagClass) !== null && _b !== void 0 ? _b : -1;\n      this.tagNumber = (_c = idBlock.tagNumber) !== null && _c !== void 0 ? _c : -1;\n      this.isConstructed = (_d = idBlock.isConstructed) !== null && _d !== void 0 ? _d : false;\n    } else {\n      this.tagClass = -1;\n      this.tagNumber = -1;\n      this.isConstructed = false;\n    }\n  }\n  toBER(sizeOnly = false) {\n    let firstOctet = 0;\n    switch (this.tagClass) {\n      case 1:\n        firstOctet |= 0;\n        break;\n      case 2:\n        firstOctet |= 64;\n        break;\n      case 3:\n        firstOctet |= 128;\n        break;\n      case 4:\n        firstOctet |= 192;\n        break;\n      default:\n        this.error = "Unknown tag class";\n        return EMPTY_BUFFER;\n    }\n    if (this.isConstructed)\n      firstOctet |= 32;\n    if (this.tagNumber < 31 && !this.isHexOnly) {\n      const retView2 = new Uint8Array(1);\n      if (!sizeOnly) {\n        let number = this.tagNumber;\n        number &= 31;\n        firstOctet |= number;\n        retView2[0] = firstOctet;\n      }\n      return retView2.buffer;\n    }\n    if (!this.isHexOnly) {\n      const encodedBuf = utilToBase(this.tagNumber, 7);\n      const encodedView = new Uint8Array(encodedBuf);\n      const size = encodedBuf.byteLength;\n      const retView2 = new Uint8Array(size + 1);\n      retView2[0] = firstOctet | 31;\n      if (!sizeOnly) {\n        for (let i = 0; i < size - 1; i++)\n          retView2[i + 1] = encodedView[i] | 128;\n        retView2[size] = encodedView[size - 1];\n      }\n      return retView2.buffer;\n    }\n    const retView = new Uint8Array(this.valueHexView.byteLength + 1);\n    retView[0] = firstOctet | 31;\n    if (!sizeOnly) {\n      const curView = this.valueHexView;\n      for (let i = 0; i < curView.length - 1; i++)\n        retView[i + 1] = curView[i] | 128;\n      retView[this.valueHexView.byteLength] = curView[curView.length - 1];\n    }\n    return retView.buffer;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);\n    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n      return -1;\n    }\n    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n    if (intBuffer.length === 0) {\n      this.error = "Zero buffer length";\n      return -1;\n    }\n    const tagClassMask = intBuffer[0] & 192;\n    switch (tagClassMask) {\n      case 0:\n        this.tagClass = 1;\n        break;\n      case 64:\n        this.tagClass = 2;\n        break;\n      case 128:\n        this.tagClass = 3;\n        break;\n      case 192:\n        this.tagClass = 4;\n        break;\n      default:\n        this.error = "Unknown tag class";\n        return -1;\n    }\n    this.isConstructed = (intBuffer[0] & 32) === 32;\n    this.isHexOnly = false;\n    const tagNumberMask = intBuffer[0] & 31;\n    if (tagNumberMask !== 31) {\n      this.tagNumber = tagNumberMask;\n      this.blockLength = 1;\n    } else {\n      let count = 1;\n      let intTagNumberBuffer = this.valueHexView = new Uint8Array(255);\n      let tagNumberBufferMaxLength = 255;\n      while (intBuffer[count] & 128) {\n        intTagNumberBuffer[count - 1] = intBuffer[count] & 127;\n        count++;\n        if (count >= intBuffer.length) {\n          this.error = "End of input reached before message was fully decoded";\n          return -1;\n        }\n        if (count === tagNumberBufferMaxLength) {\n          tagNumberBufferMaxLength += 255;\n          const tempBufferView2 = new Uint8Array(tagNumberBufferMaxLength);\n          for (let i = 0; i < intTagNumberBuffer.length; i++)\n            tempBufferView2[i] = intTagNumberBuffer[i];\n          intTagNumberBuffer = this.valueHexView = new Uint8Array(tagNumberBufferMaxLength);\n        }\n      }\n      this.blockLength = count + 1;\n      intTagNumberBuffer[count - 1] = intBuffer[count] & 127;\n      const tempBufferView = new Uint8Array(count);\n      for (let i = 0; i < count; i++)\n        tempBufferView[i] = intTagNumberBuffer[i];\n      intTagNumberBuffer = this.valueHexView = new Uint8Array(count);\n      intTagNumberBuffer.set(tempBufferView);\n      if (this.blockLength <= 9)\n        this.tagNumber = utilFromBase(intTagNumberBuffer, 7);\n      else {\n        this.isHexOnly = true;\n        this.warnings.push("Tag too long, represented as hex-coded");\n      }\n    }\n    if (this.tagClass === 1 && this.isConstructed) {\n      switch (this.tagNumber) {\n        case 1:\n        case 2:\n        case 5:\n        case 6:\n        case 9:\n        case 13:\n        case 14:\n        case 23:\n        case 24:\n        case 31:\n        case 32:\n        case 33:\n        case 34:\n          this.error = "Constructed encoding used for primitive type";\n          return -1;\n      }\n    }\n    return inputOffset + this.blockLength;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      tagClass: this.tagClass,\n      tagNumber: this.tagNumber,\n      isConstructed: this.isConstructed\n    };\n  }\n};\n__name(LocalIdentificationBlock, "LocalIdentificationBlock");\nLocalIdentificationBlock.NAME = "identificationBlock";\nvar LocalLengthBlock = class extends LocalBaseBlock {\n  constructor({ lenBlock = {} } = {}) {\n    var _a2, _b, _c;\n    super();\n    this.isIndefiniteForm = (_a2 = lenBlock.isIndefiniteForm) !== null && _a2 !== void 0 ? _a2 : false;\n    this.longFormUsed = (_b = lenBlock.longFormUsed) !== null && _b !== void 0 ? _b : false;\n    this.length = (_c = lenBlock.length) !== null && _c !== void 0 ? _c : 0;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const view = BufferSourceConverter.toUint8Array(inputBuffer);\n    if (!checkBufferParams(this, view, inputOffset, inputLength)) {\n      return -1;\n    }\n    const intBuffer = view.subarray(inputOffset, inputOffset + inputLength);\n    if (intBuffer.length === 0) {\n      this.error = "Zero buffer length";\n      return -1;\n    }\n    if (intBuffer[0] === 255) {\n      this.error = "Length block 0xFF is reserved by standard";\n      return -1;\n    }\n    this.isIndefiniteForm = intBuffer[0] === 128;\n    if (this.isIndefiniteForm) {\n      this.blockLength = 1;\n      return inputOffset + this.blockLength;\n    }\n    this.longFormUsed = !!(intBuffer[0] & 128);\n    if (this.longFormUsed === false) {\n      this.length = intBuffer[0];\n      this.blockLength = 1;\n      return inputOffset + this.blockLength;\n    }\n    const count = intBuffer[0] & 127;\n    if (count > 8) {\n      this.error = "Too big integer";\n      return -1;\n    }\n    if (count + 1 > intBuffer.length) {\n      this.error = "End of input reached before message was fully decoded";\n      return -1;\n    }\n    const lenOffset = inputOffset + 1;\n    const lengthBufferView = view.subarray(lenOffset, lenOffset + count);\n    if (lengthBufferView[count - 1] === 0)\n      this.warnings.push("Needlessly long encoded length");\n    this.length = utilFromBase(lengthBufferView, 8);\n    if (this.longFormUsed && this.length <= 127)\n      this.warnings.push("Unnecessary usage of long length form");\n    this.blockLength = count + 1;\n    return inputOffset + this.blockLength;\n  }\n  toBER(sizeOnly = false) {\n    let retBuf;\n    let retView;\n    if (this.length > 127)\n      this.longFormUsed = true;\n    if (this.isIndefiniteForm) {\n      retBuf = new ArrayBuffer(1);\n      if (sizeOnly === false) {\n        retView = new Uint8Array(retBuf);\n        retView[0] = 128;\n      }\n      return retBuf;\n    }\n    if (this.longFormUsed) {\n      const encodedBuf = utilToBase(this.length, 8);\n      if (encodedBuf.byteLength > 127) {\n        this.error = "Too big length";\n        return EMPTY_BUFFER;\n      }\n      retBuf = new ArrayBuffer(encodedBuf.byteLength + 1);\n      if (sizeOnly)\n        return retBuf;\n      const encodedView = new Uint8Array(encodedBuf);\n      retView = new Uint8Array(retBuf);\n      retView[0] = encodedBuf.byteLength | 128;\n      for (let i = 0; i < encodedBuf.byteLength; i++)\n        retView[i + 1] = encodedView[i];\n      return retBuf;\n    }\n    retBuf = new ArrayBuffer(1);\n    if (sizeOnly === false) {\n      retView = new Uint8Array(retBuf);\n      retView[0] = this.length;\n    }\n    return retBuf;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      isIndefiniteForm: this.isIndefiniteForm,\n      longFormUsed: this.longFormUsed,\n      length: this.length\n    };\n  }\n};\n__name(LocalLengthBlock, "LocalLengthBlock");\nLocalLengthBlock.NAME = "lengthBlock";\nvar typeStore = {};\nvar BaseBlock = class extends LocalBaseBlock {\n  constructor({ name = EMPTY_STRING, optional = false, primitiveSchema, ...parameters } = {}, valueBlockType) {\n    super(parameters);\n    this.name = name;\n    this.optional = optional;\n    if (primitiveSchema) {\n      this.primitiveSchema = primitiveSchema;\n    }\n    this.idBlock = new LocalIdentificationBlock(parameters);\n    this.lenBlock = new LocalLengthBlock(parameters);\n    this.valueBlock = valueBlockType ? new valueBlockType(parameters) : new ValueBlock(parameters);\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n    if (!this.idBlock.error.length)\n      this.blockLength += this.idBlock.blockLength;\n    if (!this.lenBlock.error.length)\n      this.blockLength += this.lenBlock.blockLength;\n    if (!this.valueBlock.error.length)\n      this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  }\n  toBER(sizeOnly, writer) {\n    const _writer = writer || new ViewWriter();\n    if (!writer) {\n      prepareIndefiniteForm(this);\n    }\n    const idBlockBuf = this.idBlock.toBER(sizeOnly);\n    _writer.write(idBlockBuf);\n    if (this.lenBlock.isIndefiniteForm) {\n      _writer.write(new Uint8Array([128]).buffer);\n      this.valueBlock.toBER(sizeOnly, _writer);\n      _writer.write(new ArrayBuffer(2));\n    } else {\n      const valueBlockBuf = this.valueBlock.toBER(sizeOnly);\n      this.lenBlock.length = valueBlockBuf.byteLength;\n      const lenBlockBuf = this.lenBlock.toBER(sizeOnly);\n      _writer.write(lenBlockBuf);\n      _writer.write(valueBlockBuf);\n    }\n    if (!writer) {\n      return _writer.final();\n    }\n    return EMPTY_BUFFER;\n  }\n  toJSON() {\n    const object = {\n      ...super.toJSON(),\n      idBlock: this.idBlock.toJSON(),\n      lenBlock: this.lenBlock.toJSON(),\n      valueBlock: this.valueBlock.toJSON(),\n      name: this.name,\n      optional: this.optional\n    };\n    if (this.primitiveSchema)\n      object.primitiveSchema = this.primitiveSchema.toJSON();\n    return object;\n  }\n  toString(encoding = "ascii") {\n    if (encoding === "ascii") {\n      return this.onAsciiEncoding();\n    }\n    return Convert.ToHex(this.toBER());\n  }\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${Convert.ToHex(this.valueBlock.valueBeforeDecodeView)}`;\n  }\n  isEqual(other) {\n    if (this === other) {\n      return true;\n    }\n    if (!(other instanceof this.constructor)) {\n      return false;\n    }\n    const thisRaw = this.toBER();\n    const otherRaw = other.toBER();\n    return isEqualBuffer(thisRaw, otherRaw);\n  }\n};\n__name(BaseBlock, "BaseBlock");\nBaseBlock.NAME = "BaseBlock";\nfunction prepareIndefiniteForm(baseBlock) {\n  if (baseBlock instanceof typeStore.Constructed) {\n    for (const value of baseBlock.valueBlock.value) {\n      if (prepareIndefiniteForm(value)) {\n        baseBlock.lenBlock.isIndefiniteForm = true;\n      }\n    }\n  }\n  return !!baseBlock.lenBlock.isIndefiniteForm;\n}\n__name(prepareIndefiniteForm, "prepareIndefiniteForm");\nvar BaseStringBlock = class extends BaseBlock {\n  constructor({ value = EMPTY_STRING, ...parameters } = {}, stringValueBlockType) {\n    super(parameters, stringValueBlockType);\n    if (value) {\n      this.fromString(value);\n    }\n  }\n  getValue() {\n    return this.valueBlock.value;\n  }\n  setValue(value) {\n    this.valueBlock.value = value;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n    this.fromBuffer(this.valueBlock.valueHexView);\n    if (!this.idBlock.error.length)\n      this.blockLength += this.idBlock.blockLength;\n    if (!this.lenBlock.error.length)\n      this.blockLength += this.lenBlock.blockLength;\n    if (!this.valueBlock.error.length)\n      this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  }\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : \'${this.valueBlock.value}\'`;\n  }\n};\n__name(BaseStringBlock, "BaseStringBlock");\nBaseStringBlock.NAME = "BaseStringBlock";\nvar LocalPrimitiveValueBlock = class extends HexBlock(ValueBlock) {\n  constructor({ isHexOnly = true, ...parameters } = {}) {\n    super(parameters);\n    this.isHexOnly = isHexOnly;\n  }\n};\n__name(LocalPrimitiveValueBlock, "LocalPrimitiveValueBlock");\nLocalPrimitiveValueBlock.NAME = "PrimitiveValueBlock";\nvar _a$w;\nvar Primitive = class extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalPrimitiveValueBlock);\n    this.idBlock.isConstructed = false;\n  }\n};\n__name(Primitive, "Primitive");\n_a$w = Primitive;\n(() => {\n  typeStore.Primitive = _a$w;\n})();\nPrimitive.NAME = "PRIMITIVE";\nfunction localChangeType(inputObject, newType) {\n  if (inputObject instanceof newType) {\n    return inputObject;\n  }\n  const newObject = new newType();\n  newObject.idBlock = inputObject.idBlock;\n  newObject.lenBlock = inputObject.lenBlock;\n  newObject.warnings = inputObject.warnings;\n  newObject.valueBeforeDecodeView = inputObject.valueBeforeDecodeView;\n  return newObject;\n}\n__name(localChangeType, "localChangeType");\nfunction localFromBER(inputBuffer, inputOffset = 0, inputLength = inputBuffer.length) {\n  const incomingOffset = inputOffset;\n  let returnObject = new BaseBlock({}, ValueBlock);\n  const baseBlock = new LocalBaseBlock();\n  if (!checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength)) {\n    returnObject.error = baseBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n  const intBuffer = inputBuffer.subarray(inputOffset, inputOffset + inputLength);\n  if (!intBuffer.length) {\n    returnObject.error = "Zero buffer length";\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n  let resultOffset = returnObject.idBlock.fromBER(inputBuffer, inputOffset, inputLength);\n  if (returnObject.idBlock.warnings.length) {\n    returnObject.warnings.concat(returnObject.idBlock.warnings);\n  }\n  if (resultOffset === -1) {\n    returnObject.error = returnObject.idBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n  inputOffset = resultOffset;\n  inputLength -= returnObject.idBlock.blockLength;\n  resultOffset = returnObject.lenBlock.fromBER(inputBuffer, inputOffset, inputLength);\n  if (returnObject.lenBlock.warnings.length) {\n    returnObject.warnings.concat(returnObject.lenBlock.warnings);\n  }\n  if (resultOffset === -1) {\n    returnObject.error = returnObject.lenBlock.error;\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n  inputOffset = resultOffset;\n  inputLength -= returnObject.lenBlock.blockLength;\n  if (!returnObject.idBlock.isConstructed && returnObject.lenBlock.isIndefiniteForm) {\n    returnObject.error = "Indefinite length form used for primitive encoding form";\n    return {\n      offset: -1,\n      result: returnObject\n    };\n  }\n  let newASN1Type = BaseBlock;\n  switch (returnObject.idBlock.tagClass) {\n    case 1:\n      if (returnObject.idBlock.tagNumber >= 37 && returnObject.idBlock.isHexOnly === false) {\n        returnObject.error = "UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";\n        return {\n          offset: -1,\n          result: returnObject\n        };\n      }\n      switch (returnObject.idBlock.tagNumber) {\n        case 0:\n          if (returnObject.idBlock.isConstructed && returnObject.lenBlock.length > 0) {\n            returnObject.error = "Type [UNIVERSAL 0] is reserved";\n            return {\n              offset: -1,\n              result: returnObject\n            };\n          }\n          newASN1Type = typeStore.EndOfContent;\n          break;\n        case 1:\n          newASN1Type = typeStore.Boolean;\n          break;\n        case 2:\n          newASN1Type = typeStore.Integer;\n          break;\n        case 3:\n          newASN1Type = typeStore.BitString;\n          break;\n        case 4:\n          newASN1Type = typeStore.OctetString;\n          break;\n        case 5:\n          newASN1Type = typeStore.Null;\n          break;\n        case 6:\n          newASN1Type = typeStore.ObjectIdentifier;\n          break;\n        case 10:\n          newASN1Type = typeStore.Enumerated;\n          break;\n        case 12:\n          newASN1Type = typeStore.Utf8String;\n          break;\n        case 13:\n          newASN1Type = typeStore.RelativeObjectIdentifier;\n          break;\n        case 14:\n          newASN1Type = typeStore.TIME;\n          break;\n        case 15:\n          returnObject.error = "[UNIVERSAL 15] is reserved by ASN.1 standard";\n          return {\n            offset: -1,\n            result: returnObject\n          };\n        case 16:\n          newASN1Type = typeStore.Sequence;\n          break;\n        case 17:\n          newASN1Type = typeStore.Set;\n          break;\n        case 18:\n          newASN1Type = typeStore.NumericString;\n          break;\n        case 19:\n          newASN1Type = typeStore.PrintableString;\n          break;\n        case 20:\n          newASN1Type = typeStore.TeletexString;\n          break;\n        case 21:\n          newASN1Type = typeStore.VideotexString;\n          break;\n        case 22:\n          newASN1Type = typeStore.IA5String;\n          break;\n        case 23:\n          newASN1Type = typeStore.UTCTime;\n          break;\n        case 24:\n          newASN1Type = typeStore.GeneralizedTime;\n          break;\n        case 25:\n          newASN1Type = typeStore.GraphicString;\n          break;\n        case 26:\n          newASN1Type = typeStore.VisibleString;\n          break;\n        case 27:\n          newASN1Type = typeStore.GeneralString;\n          break;\n        case 28:\n          newASN1Type = typeStore.UniversalString;\n          break;\n        case 29:\n          newASN1Type = typeStore.CharacterString;\n          break;\n        case 30:\n          newASN1Type = typeStore.BmpString;\n          break;\n        case 31:\n          newASN1Type = typeStore.DATE;\n          break;\n        case 32:\n          newASN1Type = typeStore.TimeOfDay;\n          break;\n        case 33:\n          newASN1Type = typeStore.DateTime;\n          break;\n        case 34:\n          newASN1Type = typeStore.Duration;\n          break;\n        default: {\n          const newObject = returnObject.idBlock.isConstructed ? new typeStore.Constructed() : new typeStore.Primitive();\n          newObject.idBlock = returnObject.idBlock;\n          newObject.lenBlock = returnObject.lenBlock;\n          newObject.warnings = returnObject.warnings;\n          returnObject = newObject;\n        }\n      }\n      break;\n    case 2:\n    case 3:\n    case 4:\n    default: {\n      newASN1Type = returnObject.idBlock.isConstructed ? typeStore.Constructed : typeStore.Primitive;\n    }\n  }\n  returnObject = localChangeType(returnObject, newASN1Type);\n  resultOffset = returnObject.fromBER(inputBuffer, inputOffset, returnObject.lenBlock.isIndefiniteForm ? inputLength : returnObject.lenBlock.length);\n  returnObject.valueBeforeDecodeView = inputBuffer.subarray(incomingOffset, incomingOffset + returnObject.blockLength);\n  return {\n    offset: resultOffset,\n    result: returnObject\n  };\n}\n__name(localFromBER, "localFromBER");\nfunction fromBER(inputBuffer) {\n  if (!inputBuffer.byteLength) {\n    const result = new BaseBlock({}, ValueBlock);\n    result.error = "Input buffer has zero length";\n    return {\n      offset: -1,\n      result\n    };\n  }\n  return localFromBER(BufferSourceConverter.toUint8Array(inputBuffer).slice(), 0, inputBuffer.byteLength);\n}\n__name(fromBER, "fromBER");\nfunction checkLen(indefiniteLength, length) {\n  if (indefiniteLength) {\n    return 1;\n  }\n  return length;\n}\n__name(checkLen, "checkLen");\nvar LocalConstructedValueBlock = class extends ValueBlock {\n  constructor({ value = [], isIndefiniteForm = false, ...parameters } = {}) {\n    super(parameters);\n    this.value = value;\n    this.isIndefiniteForm = isIndefiniteForm;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const view = BufferSourceConverter.toUint8Array(inputBuffer);\n    if (!checkBufferParams(this, view, inputOffset, inputLength)) {\n      return -1;\n    }\n    this.valueBeforeDecodeView = view.subarray(inputOffset, inputOffset + inputLength);\n    if (this.valueBeforeDecodeView.length === 0) {\n      this.warnings.push("Zero buffer length");\n      return inputOffset;\n    }\n    let currentOffset = inputOffset;\n    while (checkLen(this.isIndefiniteForm, inputLength) > 0) {\n      const returnObject = localFromBER(view, currentOffset, inputLength);\n      if (returnObject.offset === -1) {\n        this.error = returnObject.result.error;\n        this.warnings.concat(returnObject.result.warnings);\n        return -1;\n      }\n      currentOffset = returnObject.offset;\n      this.blockLength += returnObject.result.blockLength;\n      inputLength -= returnObject.result.blockLength;\n      this.value.push(returnObject.result);\n      if (this.isIndefiniteForm && returnObject.result.constructor.NAME === END_OF_CONTENT_NAME) {\n        break;\n      }\n    }\n    if (this.isIndefiniteForm) {\n      if (this.value[this.value.length - 1].constructor.NAME === END_OF_CONTENT_NAME) {\n        this.value.pop();\n      } else {\n        this.warnings.push("No EndOfContent block encoded");\n      }\n    }\n    return currentOffset;\n  }\n  toBER(sizeOnly, writer) {\n    const _writer = writer || new ViewWriter();\n    for (let i = 0; i < this.value.length; i++) {\n      this.value[i].toBER(sizeOnly, _writer);\n    }\n    if (!writer) {\n      return _writer.final();\n    }\n    return EMPTY_BUFFER;\n  }\n  toJSON() {\n    const object = {\n      ...super.toJSON(),\n      isIndefiniteForm: this.isIndefiniteForm,\n      value: []\n    };\n    for (const value of this.value) {\n      object.value.push(value.toJSON());\n    }\n    return object;\n  }\n};\n__name(LocalConstructedValueBlock, "LocalConstructedValueBlock");\nLocalConstructedValueBlock.NAME = "ConstructedValueBlock";\nvar _a$v;\nvar Constructed = class extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalConstructedValueBlock);\n    this.idBlock.isConstructed = true;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n    const resultOffset = this.valueBlock.fromBER(inputBuffer, inputOffset, this.lenBlock.isIndefiniteForm ? inputLength : this.lenBlock.length);\n    if (resultOffset === -1) {\n      this.error = this.valueBlock.error;\n      return resultOffset;\n    }\n    if (!this.idBlock.error.length)\n      this.blockLength += this.idBlock.blockLength;\n    if (!this.lenBlock.error.length)\n      this.blockLength += this.lenBlock.blockLength;\n    if (!this.valueBlock.error.length)\n      this.blockLength += this.valueBlock.blockLength;\n    return resultOffset;\n  }\n  onAsciiEncoding() {\n    const values = [];\n    for (const value of this.valueBlock.value) {\n      values.push(value.toString("ascii").split("\\n").map((o) => `  ${o}`).join("\\n"));\n    }\n    const blockName = this.idBlock.tagClass === 3 ? `[${this.idBlock.tagNumber}]` : this.constructor.NAME;\n    return values.length ? `${blockName} :\n${values.join("\\n")}` : `${blockName} :`;\n  }\n};\n__name(Constructed, "Constructed");\n_a$v = Constructed;\n(() => {\n  typeStore.Constructed = _a$v;\n})();\nConstructed.NAME = "CONSTRUCTED";\nvar LocalEndOfContentValueBlock = class extends ValueBlock {\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    return inputOffset;\n  }\n  toBER(sizeOnly) {\n    return EMPTY_BUFFER;\n  }\n};\n__name(LocalEndOfContentValueBlock, "LocalEndOfContentValueBlock");\nLocalEndOfContentValueBlock.override = "EndOfContentValueBlock";\nvar _a$u;\nvar EndOfContent = class extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalEndOfContentValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 0;\n  }\n};\n__name(EndOfContent, "EndOfContent");\n_a$u = EndOfContent;\n(() => {\n  typeStore.EndOfContent = _a$u;\n})();\nEndOfContent.NAME = END_OF_CONTENT_NAME;\nvar _a$t;\nvar Null = class extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, ValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 5;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (this.lenBlock.length > 0)\n      this.warnings.push("Non-zero length of value block for Null type");\n    if (!this.idBlock.error.length)\n      this.blockLength += this.idBlock.blockLength;\n    if (!this.lenBlock.error.length)\n      this.blockLength += this.lenBlock.blockLength;\n    this.blockLength += inputLength;\n    if (inputOffset + inputLength > inputBuffer.byteLength) {\n      this.error = "End of input reached before message was fully decoded (inconsistent offset and length values)";\n      return -1;\n    }\n    return inputOffset + inputLength;\n  }\n  toBER(sizeOnly, writer) {\n    const retBuf = new ArrayBuffer(2);\n    if (!sizeOnly) {\n      const retView = new Uint8Array(retBuf);\n      retView[0] = 5;\n      retView[1] = 0;\n    }\n    if (writer) {\n      writer.write(retBuf);\n    }\n    return retBuf;\n  }\n  onAsciiEncoding() {\n    return `${this.constructor.NAME}`;\n  }\n};\n__name(Null, "Null");\n_a$t = Null;\n(() => {\n  typeStore.Null = _a$t;\n})();\nNull.NAME = "NULL";\nvar LocalBooleanValueBlock = class extends HexBlock(ValueBlock) {\n  constructor({ value, ...parameters } = {}) {\n    super(parameters);\n    if (parameters.valueHex) {\n      this.valueHexView = BufferSourceConverter.toUint8Array(parameters.valueHex);\n    } else {\n      this.valueHexView = new Uint8Array(1);\n    }\n    if (value) {\n      this.value = value;\n    }\n  }\n  get value() {\n    for (const octet of this.valueHexView) {\n      if (octet > 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n  set value(value) {\n    this.valueHexView[0] = value ? 255 : 0;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);\n    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n      return -1;\n    }\n    this.valueHexView = inputView.subarray(inputOffset, inputOffset + inputLength);\n    if (inputLength > 1)\n      this.warnings.push("Boolean value encoded in more then 1 octet");\n    this.isHexOnly = true;\n    utilDecodeTC.call(this);\n    this.blockLength = inputLength;\n    return inputOffset + inputLength;\n  }\n  toBER() {\n    return this.valueHexView.slice();\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      value: this.value\n    };\n  }\n};\n__name(LocalBooleanValueBlock, "LocalBooleanValueBlock");\nLocalBooleanValueBlock.NAME = "BooleanValueBlock";\nvar _a$s;\nvar Boolean = class extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalBooleanValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 1;\n  }\n  getValue() {\n    return this.valueBlock.value;\n  }\n  setValue(value) {\n    this.valueBlock.value = value;\n  }\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${this.getValue}`;\n  }\n};\n__name(Boolean, "Boolean");\n_a$s = Boolean;\n(() => {\n  typeStore.Boolean = _a$s;\n})();\nBoolean.NAME = "BOOLEAN";\nvar LocalOctetStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {\n  constructor({ isConstructed = false, ...parameters } = {}) {\n    super(parameters);\n    this.isConstructed = isConstructed;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = 0;\n    if (this.isConstructed) {\n      this.isHexOnly = false;\n      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n      if (resultOffset === -1)\n        return resultOffset;\n      for (let i = 0; i < this.value.length; i++) {\n        const currentBlockName = this.value[i].constructor.NAME;\n        if (currentBlockName === END_OF_CONTENT_NAME) {\n          if (this.isIndefiniteForm)\n            break;\n          else {\n            this.error = "EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";\n            return -1;\n          }\n        }\n        if (currentBlockName !== OCTET_STRING_NAME) {\n          this.error = "OCTET STRING may consists of OCTET STRINGs only";\n          return -1;\n        }\n      }\n    } else {\n      this.isHexOnly = true;\n      resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n      this.blockLength = inputLength;\n    }\n    return resultOffset;\n  }\n  toBER(sizeOnly, writer) {\n    if (this.isConstructed)\n      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\n    return sizeOnly ? new ArrayBuffer(this.valueHexView.byteLength) : this.valueHexView.slice().buffer;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      isConstructed: this.isConstructed\n    };\n  }\n};\n__name(LocalOctetStringValueBlock, "LocalOctetStringValueBlock");\nLocalOctetStringValueBlock.NAME = "OctetStringValueBlock";\nvar _a$r;\nvar OctetString = class extends BaseBlock {\n  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {\n    var _b, _c;\n    (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);\n    super({\n      idBlock: {\n        isConstructed: parameters.isConstructed,\n        ...idBlock\n      },\n      lenBlock: {\n        ...lenBlock,\n        isIndefiniteForm: !!parameters.isIndefiniteForm\n      },\n      ...parameters\n    }, LocalOctetStringValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 4;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isConstructed = this.idBlock.isConstructed;\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n    if (inputLength === 0) {\n      if (this.idBlock.error.length === 0)\n        this.blockLength += this.idBlock.blockLength;\n      if (this.lenBlock.error.length === 0)\n        this.blockLength += this.lenBlock.blockLength;\n      return inputOffset;\n    }\n    if (!this.valueBlock.isConstructed) {\n      const view = inputBuffer instanceof ArrayBuffer ? new Uint8Array(inputBuffer) : inputBuffer;\n      const buf = view.subarray(inputOffset, inputOffset + inputLength);\n      try {\n        if (buf.byteLength) {\n          const asn = localFromBER(buf, 0, buf.byteLength);\n          if (asn.offset !== -1 && asn.offset === inputLength) {\n            this.valueBlock.value = [asn.result];\n          }\n        }\n      } catch (e) {\n      }\n    }\n    return super.fromBER(inputBuffer, inputOffset, inputLength);\n  }\n  onAsciiEncoding() {\n    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {\n      return Constructed.prototype.onAsciiEncoding.call(this);\n    }\n    return `${this.constructor.NAME} : ${Convert.ToHex(this.valueBlock.valueHexView)}`;\n  }\n  getValue() {\n    if (!this.idBlock.isConstructed) {\n      return this.valueBlock.valueHexView.slice().buffer;\n    }\n    const array = [];\n    for (const content of this.valueBlock.value) {\n      if (content instanceof OctetString) {\n        array.push(content.valueBlock.valueHexView);\n      }\n    }\n    return BufferSourceConverter.concat(array);\n  }\n};\n__name(OctetString, "OctetString");\n_a$r = OctetString;\n(() => {\n  typeStore.OctetString = _a$r;\n})();\nOctetString.NAME = OCTET_STRING_NAME;\nvar LocalBitStringValueBlock = class extends HexBlock(LocalConstructedValueBlock) {\n  constructor({ unusedBits = 0, isConstructed = false, ...parameters } = {}) {\n    super(parameters);\n    this.unusedBits = unusedBits;\n    this.isConstructed = isConstructed;\n    this.blockLength = this.valueHexView.byteLength;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (!inputLength) {\n      return inputOffset;\n    }\n    let resultOffset = -1;\n    if (this.isConstructed) {\n      resultOffset = LocalConstructedValueBlock.prototype.fromBER.call(this, inputBuffer, inputOffset, inputLength);\n      if (resultOffset === -1)\n        return resultOffset;\n      for (const value of this.value) {\n        const currentBlockName = value.constructor.NAME;\n        if (currentBlockName === END_OF_CONTENT_NAME) {\n          if (this.isIndefiniteForm)\n            break;\n          else {\n            this.error = "EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";\n            return -1;\n          }\n        }\n        if (currentBlockName !== BIT_STRING_NAME) {\n          this.error = "BIT STRING may consists of BIT STRINGs only";\n          return -1;\n        }\n        const valueBlock = value.valueBlock;\n        if (this.unusedBits > 0 && valueBlock.unusedBits > 0) {\n          this.error = \'Using of "unused bits" inside constructive BIT STRING allowed for least one only\';\n          return -1;\n        }\n        this.unusedBits = valueBlock.unusedBits;\n      }\n      return resultOffset;\n    }\n    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);\n    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n      return -1;\n    }\n    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n    this.unusedBits = intBuffer[0];\n    if (this.unusedBits > 7) {\n      this.error = "Unused bits for BitString must be in range 0-7";\n      return -1;\n    }\n    if (!this.unusedBits) {\n      const buf = intBuffer.subarray(1);\n      try {\n        if (buf.byteLength) {\n          const asn = localFromBER(buf, 0, buf.byteLength);\n          if (asn.offset !== -1 && asn.offset === inputLength - 1) {\n            this.value = [asn.result];\n          }\n        }\n      } catch (e) {\n      }\n    }\n    this.valueHexView = intBuffer.subarray(1);\n    this.blockLength = intBuffer.length;\n    return inputOffset + inputLength;\n  }\n  toBER(sizeOnly, writer) {\n    if (this.isConstructed) {\n      return LocalConstructedValueBlock.prototype.toBER.call(this, sizeOnly, writer);\n    }\n    if (sizeOnly) {\n      return new ArrayBuffer(this.valueHexView.byteLength + 1);\n    }\n    if (!this.valueHexView.byteLength) {\n      return EMPTY_BUFFER;\n    }\n    const retView = new Uint8Array(this.valueHexView.length + 1);\n    retView[0] = this.unusedBits;\n    retView.set(this.valueHexView, 1);\n    return retView.buffer;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      unusedBits: this.unusedBits,\n      isConstructed: this.isConstructed\n    };\n  }\n};\n__name(LocalBitStringValueBlock, "LocalBitStringValueBlock");\nLocalBitStringValueBlock.NAME = "BitStringValueBlock";\nvar _a$q;\nvar BitString = class extends BaseBlock {\n  constructor({ idBlock = {}, lenBlock = {}, ...parameters } = {}) {\n    var _b, _c;\n    (_b = parameters.isConstructed) !== null && _b !== void 0 ? _b : parameters.isConstructed = !!((_c = parameters.value) === null || _c === void 0 ? void 0 : _c.length);\n    super({\n      idBlock: {\n        isConstructed: parameters.isConstructed,\n        ...idBlock\n      },\n      lenBlock: {\n        ...lenBlock,\n        isIndefiniteForm: !!parameters.isIndefiniteForm\n      },\n      ...parameters\n    }, LocalBitStringValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 3;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    this.valueBlock.isConstructed = this.idBlock.isConstructed;\n    this.valueBlock.isIndefiniteForm = this.lenBlock.isIndefiniteForm;\n    return super.fromBER(inputBuffer, inputOffset, inputLength);\n  }\n  onAsciiEncoding() {\n    if (this.valueBlock.isConstructed || this.valueBlock.value && this.valueBlock.value.length) {\n      return Constructed.prototype.onAsciiEncoding.call(this);\n    } else {\n      const bits = [];\n      const valueHex = this.valueBlock.valueHexView;\n      for (const byte of valueHex) {\n        bits.push(byte.toString(2).padStart(8, "0"));\n      }\n      const bitsStr = bits.join("");\n      return `${this.constructor.NAME} : ${bitsStr.substring(0, bitsStr.length - this.valueBlock.unusedBits)}`;\n    }\n  }\n};\n__name(BitString, "BitString");\n_a$q = BitString;\n(() => {\n  typeStore.BitString = _a$q;\n})();\nBitString.NAME = BIT_STRING_NAME;\nvar _a$p;\nfunction viewAdd(first, second) {\n  const c = new Uint8Array([0]);\n  const firstView = new Uint8Array(first);\n  const secondView = new Uint8Array(second);\n  let firstViewCopy = firstView.slice(0);\n  const firstViewCopyLength = firstViewCopy.length - 1;\n  const secondViewCopy = secondView.slice(0);\n  const secondViewCopyLength = secondViewCopy.length - 1;\n  let value = 0;\n  const max = secondViewCopyLength < firstViewCopyLength ? firstViewCopyLength : secondViewCopyLength;\n  let counter = 0;\n  for (let i = max; i >= 0; i--, counter++) {\n    switch (true) {\n      case counter < secondViewCopy.length:\n        value = firstViewCopy[firstViewCopyLength - counter] + secondViewCopy[secondViewCopyLength - counter] + c[0];\n        break;\n      default:\n        value = firstViewCopy[firstViewCopyLength - counter] + c[0];\n    }\n    c[0] = value / 10;\n    switch (true) {\n      case counter >= firstViewCopy.length:\n        firstViewCopy = utilConcatView(new Uint8Array([value % 10]), firstViewCopy);\n        break;\n      default:\n        firstViewCopy[firstViewCopyLength - counter] = value % 10;\n    }\n  }\n  if (c[0] > 0)\n    firstViewCopy = utilConcatView(c, firstViewCopy);\n  return firstViewCopy;\n}\n__name(viewAdd, "viewAdd");\nfunction power2(n) {\n  if (n >= powers2.length) {\n    for (let p = powers2.length; p <= n; p++) {\n      const c = new Uint8Array([0]);\n      let digits = powers2[p - 1].slice(0);\n      for (let i = digits.length - 1; i >= 0; i--) {\n        const newValue = new Uint8Array([(digits[i] << 1) + c[0]]);\n        c[0] = newValue[0] / 10;\n        digits[i] = newValue[0] % 10;\n      }\n      if (c[0] > 0)\n        digits = utilConcatView(c, digits);\n      powers2.push(digits);\n    }\n  }\n  return powers2[n];\n}\n__name(power2, "power2");\nfunction viewSub(first, second) {\n  let b = 0;\n  const firstView = new Uint8Array(first);\n  const secondView = new Uint8Array(second);\n  const firstViewCopy = firstView.slice(0);\n  const firstViewCopyLength = firstViewCopy.length - 1;\n  const secondViewCopy = secondView.slice(0);\n  const secondViewCopyLength = secondViewCopy.length - 1;\n  let value;\n  let counter = 0;\n  for (let i = secondViewCopyLength; i >= 0; i--, counter++) {\n    value = firstViewCopy[firstViewCopyLength - counter] - secondViewCopy[secondViewCopyLength - counter] - b;\n    switch (true) {\n      case value < 0:\n        b = 1;\n        firstViewCopy[firstViewCopyLength - counter] = value + 10;\n        break;\n      default:\n        b = 0;\n        firstViewCopy[firstViewCopyLength - counter] = value;\n    }\n  }\n  if (b > 0) {\n    for (let i = firstViewCopyLength - secondViewCopyLength + 1; i >= 0; i--, counter++) {\n      value = firstViewCopy[firstViewCopyLength - counter] - b;\n      if (value < 0) {\n        b = 1;\n        firstViewCopy[firstViewCopyLength - counter] = value + 10;\n      } else {\n        b = 0;\n        firstViewCopy[firstViewCopyLength - counter] = value;\n        break;\n      }\n    }\n  }\n  return firstViewCopy.slice();\n}\n__name(viewSub, "viewSub");\nvar LocalIntegerValueBlock = class extends HexBlock(ValueBlock) {\n  constructor({ value, ...parameters } = {}) {\n    super(parameters);\n    this._valueDec = 0;\n    if (parameters.valueHex) {\n      this.setValueHex();\n    }\n    if (value !== void 0) {\n      this.valueDec = value;\n    }\n  }\n  setValueHex() {\n    if (this.valueHexView.length >= 4) {\n      this.warnings.push("Too big Integer for decoding, hex only");\n      this.isHexOnly = true;\n      this._valueDec = 0;\n    } else {\n      this.isHexOnly = false;\n      if (this.valueHexView.length > 0) {\n        this._valueDec = utilDecodeTC.call(this);\n      }\n    }\n  }\n  set valueDec(v) {\n    this._valueDec = v;\n    this.isHexOnly = false;\n    this.valueHexView = new Uint8Array(utilEncodeTC(v));\n  }\n  get valueDec() {\n    return this._valueDec;\n  }\n  fromDER(inputBuffer, inputOffset, inputLength, expectedLength = 0) {\n    const offset = this.fromBER(inputBuffer, inputOffset, inputLength);\n    if (offset === -1)\n      return offset;\n    const view = this.valueHexView;\n    if (view[0] === 0 && (view[1] & 128) !== 0) {\n      this.valueHexView = view.subarray(1);\n    } else {\n      if (expectedLength !== 0) {\n        if (view.length < expectedLength) {\n          if (expectedLength - view.length > 1)\n            expectedLength = view.length + 1;\n          this.valueHexView = view.subarray(expectedLength - view.length);\n        }\n      }\n    }\n    return offset;\n  }\n  toDER(sizeOnly = false) {\n    const view = this.valueHexView;\n    switch (true) {\n      case (view[0] & 128) !== 0:\n        {\n          const updatedView = new Uint8Array(this.valueHexView.length + 1);\n          updatedView[0] = 0;\n          updatedView.set(view, 1);\n          this.valueHexView = updatedView;\n        }\n        break;\n      case (view[0] === 0 && (view[1] & 128) === 0):\n        {\n          this.valueHexView = this.valueHexView.subarray(1);\n        }\n        break;\n    }\n    return this.toBER(sizeOnly);\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const resultOffset = super.fromBER(inputBuffer, inputOffset, inputLength);\n    if (resultOffset === -1) {\n      return resultOffset;\n    }\n    this.setValueHex();\n    return resultOffset;\n  }\n  toBER(sizeOnly) {\n    return sizeOnly ? new ArrayBuffer(this.valueHexView.length) : this.valueHexView.slice().buffer;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      valueDec: this.valueDec\n    };\n  }\n  toString() {\n    const firstBit = this.valueHexView.length * 8 - 1;\n    let digits = new Uint8Array(this.valueHexView.length * 8 / 3);\n    let bitNumber = 0;\n    let currentByte;\n    const asn1View = this.valueHexView;\n    let result = "";\n    let flag = false;\n    for (let byteNumber = asn1View.byteLength - 1; byteNumber >= 0; byteNumber--) {\n      currentByte = asn1View[byteNumber];\n      for (let i = 0; i < 8; i++) {\n        if ((currentByte & 1) === 1) {\n          switch (bitNumber) {\n            case firstBit:\n              digits = viewSub(power2(bitNumber), digits);\n              result = "-";\n              break;\n            default:\n              digits = viewAdd(digits, power2(bitNumber));\n          }\n        }\n        bitNumber++;\n        currentByte >>= 1;\n      }\n    }\n    for (let i = 0; i < digits.length; i++) {\n      if (digits[i])\n        flag = true;\n      if (flag)\n        result += digitsString.charAt(digits[i]);\n    }\n    if (flag === false)\n      result += digitsString.charAt(0);\n    return result;\n  }\n};\n__name(LocalIntegerValueBlock, "LocalIntegerValueBlock");\n_a$p = LocalIntegerValueBlock;\nLocalIntegerValueBlock.NAME = "IntegerValueBlock";\n(() => {\n  Object.defineProperty(_a$p.prototype, "valueHex", {\n    set: function(v) {\n      this.valueHexView = new Uint8Array(v);\n      this.setValueHex();\n    },\n    get: function() {\n      return this.valueHexView.slice().buffer;\n    }\n  });\n})();\nvar _a$o;\nvar Integer = class extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalIntegerValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 2;\n  }\n  toBigInt() {\n    assertBigInt();\n    return BigInt(this.valueBlock.toString());\n  }\n  static fromBigInt(value) {\n    assertBigInt();\n    const bigIntValue = BigInt(value);\n    const writer = new ViewWriter();\n    const hex = bigIntValue.toString(16).replace(/^-/, "");\n    const view = new Uint8Array(Convert.FromHex(hex));\n    if (bigIntValue < 0) {\n      const first = new Uint8Array(view.length + (view[0] & 128 ? 1 : 0));\n      first[0] |= 128;\n      const firstInt = BigInt(`0x${Convert.ToHex(first)}`);\n      const secondInt = firstInt + bigIntValue;\n      const second = BufferSourceConverter.toUint8Array(Convert.FromHex(secondInt.toString(16)));\n      second[0] |= 128;\n      writer.write(second);\n    } else {\n      if (view[0] & 128) {\n        writer.write(new Uint8Array([0]));\n      }\n      writer.write(view);\n    }\n    const res = new Integer({\n      valueHex: writer.final()\n    });\n    return res;\n  }\n  convertToDER() {\n    const integer = new Integer({ valueHex: this.valueBlock.valueHexView });\n    integer.valueBlock.toDER();\n    return integer;\n  }\n  convertFromDER() {\n    return new Integer({\n      valueHex: this.valueBlock.valueHexView[0] === 0 ? this.valueBlock.valueHexView.subarray(1) : this.valueBlock.valueHexView\n    });\n  }\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${this.valueBlock.toString()}`;\n  }\n};\n__name(Integer, "Integer");\n_a$o = Integer;\n(() => {\n  typeStore.Integer = _a$o;\n})();\nInteger.NAME = "INTEGER";\nvar _a$n;\nvar Enumerated = class extends Integer {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 10;\n  }\n};\n__name(Enumerated, "Enumerated");\n_a$n = Enumerated;\n(() => {\n  typeStore.Enumerated = _a$n;\n})();\nEnumerated.NAME = "ENUMERATED";\nvar LocalSidValueBlock = class extends HexBlock(ValueBlock) {\n  constructor({ valueDec = -1, isFirstSid = false, ...parameters } = {}) {\n    super(parameters);\n    this.valueDec = valueDec;\n    this.isFirstSid = isFirstSid;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (!inputLength) {\n      return inputOffset;\n    }\n    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);\n    if (!checkBufferParams(this, inputView, inputOffset, inputLength)) {\n      return -1;\n    }\n    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n    this.valueHexView = new Uint8Array(inputLength);\n    for (let i = 0; i < inputLength; i++) {\n      this.valueHexView[i] = intBuffer[i] & 127;\n      this.blockLength++;\n      if ((intBuffer[i] & 128) === 0)\n        break;\n    }\n    const tempView = new Uint8Array(this.blockLength);\n    for (let i = 0; i < this.blockLength; i++) {\n      tempView[i] = this.valueHexView[i];\n    }\n    this.valueHexView = tempView;\n    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {\n      this.error = "End of input reached before message was fully decoded";\n      return -1;\n    }\n    if (this.valueHexView[0] === 0)\n      this.warnings.push("Needlessly long format of SID encoding");\n    if (this.blockLength <= 8)\n      this.valueDec = utilFromBase(this.valueHexView, 7);\n    else {\n      this.isHexOnly = true;\n      this.warnings.push("Too big SID for decoding, hex only");\n    }\n    return inputOffset + this.blockLength;\n  }\n  set valueBigInt(value) {\n    assertBigInt();\n    let bits = BigInt(value).toString(2);\n    while (bits.length % 7) {\n      bits = "0" + bits;\n    }\n    const bytes = new Uint8Array(bits.length / 7);\n    for (let i = 0; i < bytes.length; i++) {\n      bytes[i] = parseInt(bits.slice(i * 7, i * 7 + 7), 2) + (i + 1 < bytes.length ? 128 : 0);\n    }\n    this.fromBER(bytes.buffer, 0, bytes.length);\n  }\n  toBER(sizeOnly) {\n    if (this.isHexOnly) {\n      if (sizeOnly)\n        return new ArrayBuffer(this.valueHexView.byteLength);\n      const curView = this.valueHexView;\n      const retView2 = new Uint8Array(this.blockLength);\n      for (let i = 0; i < this.blockLength - 1; i++)\n        retView2[i] = curView[i] | 128;\n      retView2[this.blockLength - 1] = curView[this.blockLength - 1];\n      return retView2.buffer;\n    }\n    const encodedBuf = utilToBase(this.valueDec, 7);\n    if (encodedBuf.byteLength === 0) {\n      this.error = "Error during encoding SID value";\n      return EMPTY_BUFFER;\n    }\n    const retView = new Uint8Array(encodedBuf.byteLength);\n    if (!sizeOnly) {\n      const encodedView = new Uint8Array(encodedBuf);\n      const len = encodedBuf.byteLength - 1;\n      for (let i = 0; i < len; i++)\n        retView[i] = encodedView[i] | 128;\n      retView[len] = encodedView[len];\n    }\n    return retView;\n  }\n  toString() {\n    let result = "";\n    if (this.isHexOnly)\n      result = Convert.ToHex(this.valueHexView);\n    else {\n      if (this.isFirstSid) {\n        let sidValue = this.valueDec;\n        if (this.valueDec <= 39)\n          result = "0.";\n        else {\n          if (this.valueDec <= 79) {\n            result = "1.";\n            sidValue -= 40;\n          } else {\n            result = "2.";\n            sidValue -= 80;\n          }\n        }\n        result += sidValue.toString();\n      } else\n        result = this.valueDec.toString();\n    }\n    return result;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      valueDec: this.valueDec,\n      isFirstSid: this.isFirstSid\n    };\n  }\n};\n__name(LocalSidValueBlock, "LocalSidValueBlock");\nLocalSidValueBlock.NAME = "sidBlock";\nvar LocalObjectIdentifierValueBlock = class extends ValueBlock {\n  constructor({ value = EMPTY_STRING, ...parameters } = {}) {\n    super(parameters);\n    this.value = [];\n    if (value) {\n      this.fromString(value);\n    }\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = inputOffset;\n    while (inputLength > 0) {\n      const sidBlock = new LocalSidValueBlock();\n      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n      if (resultOffset === -1) {\n        this.blockLength = 0;\n        this.error = sidBlock.error;\n        return resultOffset;\n      }\n      if (this.value.length === 0)\n        sidBlock.isFirstSid = true;\n      this.blockLength += sidBlock.blockLength;\n      inputLength -= sidBlock.blockLength;\n      this.value.push(sidBlock);\n    }\n    return resultOffset;\n  }\n  toBER(sizeOnly) {\n    const retBuffers = [];\n    for (let i = 0; i < this.value.length; i++) {\n      const valueBuf = this.value[i].toBER(sizeOnly);\n      if (valueBuf.byteLength === 0) {\n        this.error = this.value[i].error;\n        return EMPTY_BUFFER;\n      }\n      retBuffers.push(valueBuf);\n    }\n    return concat(retBuffers);\n  }\n  fromString(string) {\n    this.value = [];\n    let pos1 = 0;\n    let pos2 = 0;\n    let sid = "";\n    let flag = false;\n    do {\n      pos2 = string.indexOf(".", pos1);\n      if (pos2 === -1)\n        sid = string.substring(pos1);\n      else\n        sid = string.substring(pos1, pos2);\n      pos1 = pos2 + 1;\n      if (flag) {\n        const sidBlock = this.value[0];\n        let plus = 0;\n        switch (sidBlock.valueDec) {\n          case 0:\n            break;\n          case 1:\n            plus = 40;\n            break;\n          case 2:\n            plus = 80;\n            break;\n          default:\n            this.value = [];\n            return;\n        }\n        const parsedSID = parseInt(sid, 10);\n        if (isNaN(parsedSID))\n          return;\n        sidBlock.valueDec = parsedSID + plus;\n        flag = false;\n      } else {\n        const sidBlock = new LocalSidValueBlock();\n        if (sid > Number.MAX_SAFE_INTEGER) {\n          assertBigInt();\n          const sidValue = BigInt(sid);\n          sidBlock.valueBigInt = sidValue;\n        } else {\n          sidBlock.valueDec = parseInt(sid, 10);\n          if (isNaN(sidBlock.valueDec))\n            return;\n        }\n        if (!this.value.length) {\n          sidBlock.isFirstSid = true;\n          flag = true;\n        }\n        this.value.push(sidBlock);\n      }\n    } while (pos2 !== -1);\n  }\n  toString() {\n    let result = "";\n    let isHexOnly = false;\n    for (let i = 0; i < this.value.length; i++) {\n      isHexOnly = this.value[i].isHexOnly;\n      let sidStr = this.value[i].toString();\n      if (i !== 0)\n        result = `${result}.`;\n      if (isHexOnly) {\n        sidStr = `{${sidStr}}`;\n        if (this.value[i].isFirstSid)\n          result = `2.{${sidStr} - 80}`;\n        else\n          result += sidStr;\n      } else\n        result += sidStr;\n    }\n    return result;\n  }\n  toJSON() {\n    const object = {\n      ...super.toJSON(),\n      value: this.toString(),\n      sidArray: []\n    };\n    for (let i = 0; i < this.value.length; i++) {\n      object.sidArray.push(this.value[i].toJSON());\n    }\n    return object;\n  }\n};\n__name(LocalObjectIdentifierValueBlock, "LocalObjectIdentifierValueBlock");\nLocalObjectIdentifierValueBlock.NAME = "ObjectIdentifierValueBlock";\nvar _a$m;\nvar ObjectIdentifier = class extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalObjectIdentifierValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 6;\n  }\n  getValue() {\n    return this.valueBlock.toString();\n  }\n  setValue(value) {\n    this.valueBlock.fromString(value);\n  }\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      value: this.getValue()\n    };\n  }\n};\n__name(ObjectIdentifier, "ObjectIdentifier");\n_a$m = ObjectIdentifier;\n(() => {\n  typeStore.ObjectIdentifier = _a$m;\n})();\nObjectIdentifier.NAME = "OBJECT IDENTIFIER";\nvar LocalRelativeSidValueBlock = class extends HexBlock(LocalBaseBlock) {\n  constructor({ valueDec = 0, ...parameters } = {}) {\n    super(parameters);\n    this.valueDec = valueDec;\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    if (inputLength === 0)\n      return inputOffset;\n    const inputView = BufferSourceConverter.toUint8Array(inputBuffer);\n    if (!checkBufferParams(this, inputView, inputOffset, inputLength))\n      return -1;\n    const intBuffer = inputView.subarray(inputOffset, inputOffset + inputLength);\n    this.valueHexView = new Uint8Array(inputLength);\n    for (let i = 0; i < inputLength; i++) {\n      this.valueHexView[i] = intBuffer[i] & 127;\n      this.blockLength++;\n      if ((intBuffer[i] & 128) === 0)\n        break;\n    }\n    const tempView = new Uint8Array(this.blockLength);\n    for (let i = 0; i < this.blockLength; i++)\n      tempView[i] = this.valueHexView[i];\n    this.valueHexView = tempView;\n    if ((intBuffer[this.blockLength - 1] & 128) !== 0) {\n      this.error = "End of input reached before message was fully decoded";\n      return -1;\n    }\n    if (this.valueHexView[0] === 0)\n      this.warnings.push("Needlessly long format of SID encoding");\n    if (this.blockLength <= 8)\n      this.valueDec = utilFromBase(this.valueHexView, 7);\n    else {\n      this.isHexOnly = true;\n      this.warnings.push("Too big SID for decoding, hex only");\n    }\n    return inputOffset + this.blockLength;\n  }\n  toBER(sizeOnly) {\n    if (this.isHexOnly) {\n      if (sizeOnly)\n        return new ArrayBuffer(this.valueHexView.byteLength);\n      const curView = this.valueHexView;\n      const retView2 = new Uint8Array(this.blockLength);\n      for (let i = 0; i < this.blockLength - 1; i++)\n        retView2[i] = curView[i] | 128;\n      retView2[this.blockLength - 1] = curView[this.blockLength - 1];\n      return retView2.buffer;\n    }\n    const encodedBuf = utilToBase(this.valueDec, 7);\n    if (encodedBuf.byteLength === 0) {\n      this.error = "Error during encoding SID value";\n      return EMPTY_BUFFER;\n    }\n    const retView = new Uint8Array(encodedBuf.byteLength);\n    if (!sizeOnly) {\n      const encodedView = new Uint8Array(encodedBuf);\n      const len = encodedBuf.byteLength - 1;\n      for (let i = 0; i < len; i++)\n        retView[i] = encodedView[i] | 128;\n      retView[len] = encodedView[len];\n    }\n    return retView.buffer;\n  }\n  toString() {\n    let result = "";\n    if (this.isHexOnly)\n      result = Convert.ToHex(this.valueHexView);\n    else {\n      result = this.valueDec.toString();\n    }\n    return result;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      valueDec: this.valueDec\n    };\n  }\n};\n__name(LocalRelativeSidValueBlock, "LocalRelativeSidValueBlock");\nLocalRelativeSidValueBlock.NAME = "relativeSidBlock";\nvar LocalRelativeObjectIdentifierValueBlock = class extends ValueBlock {\n  constructor({ value = EMPTY_STRING, ...parameters } = {}) {\n    super(parameters);\n    this.value = [];\n    if (value) {\n      this.fromString(value);\n    }\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    let resultOffset = inputOffset;\n    while (inputLength > 0) {\n      const sidBlock = new LocalRelativeSidValueBlock();\n      resultOffset = sidBlock.fromBER(inputBuffer, resultOffset, inputLength);\n      if (resultOffset === -1) {\n        this.blockLength = 0;\n        this.error = sidBlock.error;\n        return resultOffset;\n      }\n      this.blockLength += sidBlock.blockLength;\n      inputLength -= sidBlock.blockLength;\n      this.value.push(sidBlock);\n    }\n    return resultOffset;\n  }\n  toBER(sizeOnly, writer) {\n    const retBuffers = [];\n    for (let i = 0; i < this.value.length; i++) {\n      const valueBuf = this.value[i].toBER(sizeOnly);\n      if (valueBuf.byteLength === 0) {\n        this.error = this.value[i].error;\n        return EMPTY_BUFFER;\n      }\n      retBuffers.push(valueBuf);\n    }\n    return concat(retBuffers);\n  }\n  fromString(string) {\n    this.value = [];\n    let pos1 = 0;\n    let pos2 = 0;\n    let sid = "";\n    do {\n      pos2 = string.indexOf(".", pos1);\n      if (pos2 === -1)\n        sid = string.substring(pos1);\n      else\n        sid = string.substring(pos1, pos2);\n      pos1 = pos2 + 1;\n      const sidBlock = new LocalRelativeSidValueBlock();\n      sidBlock.valueDec = parseInt(sid, 10);\n      if (isNaN(sidBlock.valueDec))\n        return true;\n      this.value.push(sidBlock);\n    } while (pos2 !== -1);\n    return true;\n  }\n  toString() {\n    let result = "";\n    let isHexOnly = false;\n    for (let i = 0; i < this.value.length; i++) {\n      isHexOnly = this.value[i].isHexOnly;\n      let sidStr = this.value[i].toString();\n      if (i !== 0)\n        result = `${result}.`;\n      if (isHexOnly) {\n        sidStr = `{${sidStr}}`;\n        result += sidStr;\n      } else\n        result += sidStr;\n    }\n    return result;\n  }\n  toJSON() {\n    const object = {\n      ...super.toJSON(),\n      value: this.toString(),\n      sidArray: []\n    };\n    for (let i = 0; i < this.value.length; i++)\n      object.sidArray.push(this.value[i].toJSON());\n    return object;\n  }\n};\n__name(LocalRelativeObjectIdentifierValueBlock, "LocalRelativeObjectIdentifierValueBlock");\nLocalRelativeObjectIdentifierValueBlock.NAME = "RelativeObjectIdentifierValueBlock";\nvar _a$l;\nvar RelativeObjectIdentifier = class extends BaseBlock {\n  constructor(parameters = {}) {\n    super(parameters, LocalRelativeObjectIdentifierValueBlock);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 13;\n  }\n  getValue() {\n    return this.valueBlock.toString();\n  }\n  setValue(value) {\n    this.valueBlock.fromString(value);\n  }\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${this.valueBlock.toString() || "empty"}`;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      value: this.getValue()\n    };\n  }\n};\n__name(RelativeObjectIdentifier, "RelativeObjectIdentifier");\n_a$l = RelativeObjectIdentifier;\n(() => {\n  typeStore.RelativeObjectIdentifier = _a$l;\n})();\nRelativeObjectIdentifier.NAME = "RelativeObjectIdentifier";\nvar _a$k;\nvar Sequence = class extends Constructed {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 16;\n  }\n};\n__name(Sequence, "Sequence");\n_a$k = Sequence;\n(() => {\n  typeStore.Sequence = _a$k;\n})();\nSequence.NAME = "SEQUENCE";\nvar _a$j;\nvar Set = class extends Constructed {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 17;\n  }\n};\n__name(Set, "Set");\n_a$j = Set;\n(() => {\n  typeStore.Set = _a$j;\n})();\nSet.NAME = "SET";\nvar LocalStringValueBlock = class extends HexBlock(ValueBlock) {\n  constructor({ ...parameters } = {}) {\n    super(parameters);\n    this.isHexOnly = true;\n    this.value = EMPTY_STRING;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      value: this.value\n    };\n  }\n};\n__name(LocalStringValueBlock, "LocalStringValueBlock");\nLocalStringValueBlock.NAME = "StringValueBlock";\nvar LocalSimpleStringValueBlock = class extends LocalStringValueBlock {\n};\n__name(LocalSimpleStringValueBlock, "LocalSimpleStringValueBlock");\nLocalSimpleStringValueBlock.NAME = "SimpleStringValueBlock";\nvar LocalSimpleStringBlock = class extends BaseStringBlock {\n  constructor({ ...parameters } = {}) {\n    super(parameters, LocalSimpleStringValueBlock);\n  }\n  fromBuffer(inputBuffer) {\n    this.valueBlock.value = String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer));\n  }\n  fromString(inputString) {\n    const strLen = inputString.length;\n    const view = this.valueBlock.valueHexView = new Uint8Array(strLen);\n    for (let i = 0; i < strLen; i++)\n      view[i] = inputString.charCodeAt(i);\n    this.valueBlock.value = inputString;\n  }\n};\n__name(LocalSimpleStringBlock, "LocalSimpleStringBlock");\nLocalSimpleStringBlock.NAME = "SIMPLE STRING";\nvar LocalUtf8StringValueBlock = class extends LocalSimpleStringBlock {\n  fromBuffer(inputBuffer) {\n    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);\n    try {\n      this.valueBlock.value = Convert.ToUtf8String(inputBuffer);\n    } catch (ex) {\n      this.warnings.push(`Error during "decodeURIComponent": ${ex}, using raw string`);\n      this.valueBlock.value = Convert.ToBinary(inputBuffer);\n    }\n  }\n  fromString(inputString) {\n    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf8String(inputString));\n    this.valueBlock.value = inputString;\n  }\n};\n__name(LocalUtf8StringValueBlock, "LocalUtf8StringValueBlock");\nLocalUtf8StringValueBlock.NAME = "Utf8StringValueBlock";\nvar _a$i;\nvar Utf8String = class extends LocalUtf8StringValueBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 12;\n  }\n};\n__name(Utf8String, "Utf8String");\n_a$i = Utf8String;\n(() => {\n  typeStore.Utf8String = _a$i;\n})();\nUtf8String.NAME = "UTF8String";\nvar LocalBmpStringValueBlock = class extends LocalSimpleStringBlock {\n  fromBuffer(inputBuffer) {\n    this.valueBlock.value = Convert.ToUtf16String(inputBuffer);\n    this.valueBlock.valueHexView = BufferSourceConverter.toUint8Array(inputBuffer);\n  }\n  fromString(inputString) {\n    this.valueBlock.value = inputString;\n    this.valueBlock.valueHexView = new Uint8Array(Convert.FromUtf16String(inputString));\n  }\n};\n__name(LocalBmpStringValueBlock, "LocalBmpStringValueBlock");\nLocalBmpStringValueBlock.NAME = "BmpStringValueBlock";\nvar _a$h;\nvar BmpString = class extends LocalBmpStringValueBlock {\n  constructor({ ...parameters } = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 30;\n  }\n};\n__name(BmpString, "BmpString");\n_a$h = BmpString;\n(() => {\n  typeStore.BmpString = _a$h;\n})();\nBmpString.NAME = "BMPString";\nvar LocalUniversalStringValueBlock = class extends LocalSimpleStringBlock {\n  fromBuffer(inputBuffer) {\n    const copyBuffer = ArrayBuffer.isView(inputBuffer) ? inputBuffer.slice().buffer : inputBuffer.slice(0);\n    const valueView = new Uint8Array(copyBuffer);\n    for (let i = 0; i < valueView.length; i += 4) {\n      valueView[i] = valueView[i + 3];\n      valueView[i + 1] = valueView[i + 2];\n      valueView[i + 2] = 0;\n      valueView[i + 3] = 0;\n    }\n    this.valueBlock.value = String.fromCharCode.apply(null, new Uint32Array(copyBuffer));\n  }\n  fromString(inputString) {\n    const strLength = inputString.length;\n    const valueHexView = this.valueBlock.valueHexView = new Uint8Array(strLength * 4);\n    for (let i = 0; i < strLength; i++) {\n      const codeBuf = utilToBase(inputString.charCodeAt(i), 8);\n      const codeView = new Uint8Array(codeBuf);\n      if (codeView.length > 4)\n        continue;\n      const dif = 4 - codeView.length;\n      for (let j = codeView.length - 1; j >= 0; j--)\n        valueHexView[i * 4 + j + dif] = codeView[j];\n    }\n    this.valueBlock.value = inputString;\n  }\n};\n__name(LocalUniversalStringValueBlock, "LocalUniversalStringValueBlock");\nLocalUniversalStringValueBlock.NAME = "UniversalStringValueBlock";\nvar _a$g;\nvar UniversalString = class extends LocalUniversalStringValueBlock {\n  constructor({ ...parameters } = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 28;\n  }\n};\n__name(UniversalString, "UniversalString");\n_a$g = UniversalString;\n(() => {\n  typeStore.UniversalString = _a$g;\n})();\nUniversalString.NAME = "UniversalString";\nvar _a$f;\nvar NumericString = class extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 18;\n  }\n};\n__name(NumericString, "NumericString");\n_a$f = NumericString;\n(() => {\n  typeStore.NumericString = _a$f;\n})();\nNumericString.NAME = "NumericString";\nvar _a$e;\nvar PrintableString = class extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 19;\n  }\n};\n__name(PrintableString, "PrintableString");\n_a$e = PrintableString;\n(() => {\n  typeStore.PrintableString = _a$e;\n})();\nPrintableString.NAME = "PrintableString";\nvar _a$d;\nvar TeletexString = class extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 20;\n  }\n};\n__name(TeletexString, "TeletexString");\n_a$d = TeletexString;\n(() => {\n  typeStore.TeletexString = _a$d;\n})();\nTeletexString.NAME = "TeletexString";\nvar _a$c;\nvar VideotexString = class extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 21;\n  }\n};\n__name(VideotexString, "VideotexString");\n_a$c = VideotexString;\n(() => {\n  typeStore.VideotexString = _a$c;\n})();\nVideotexString.NAME = "VideotexString";\nvar _a$b;\nvar IA5String = class extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 22;\n  }\n};\n__name(IA5String, "IA5String");\n_a$b = IA5String;\n(() => {\n  typeStore.IA5String = _a$b;\n})();\nIA5String.NAME = "IA5String";\nvar _a$a;\nvar GraphicString = class extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 25;\n  }\n};\n__name(GraphicString, "GraphicString");\n_a$a = GraphicString;\n(() => {\n  typeStore.GraphicString = _a$a;\n})();\nGraphicString.NAME = "GraphicString";\nvar _a$9;\nvar VisibleString = class extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 26;\n  }\n};\n__name(VisibleString, "VisibleString");\n_a$9 = VisibleString;\n(() => {\n  typeStore.VisibleString = _a$9;\n})();\nVisibleString.NAME = "VisibleString";\nvar _a$8;\nvar GeneralString = class extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 27;\n  }\n};\n__name(GeneralString, "GeneralString");\n_a$8 = GeneralString;\n(() => {\n  typeStore.GeneralString = _a$8;\n})();\nGeneralString.NAME = "GeneralString";\nvar _a$7;\nvar CharacterString = class extends LocalSimpleStringBlock {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 29;\n  }\n};\n__name(CharacterString, "CharacterString");\n_a$7 = CharacterString;\n(() => {\n  typeStore.CharacterString = _a$7;\n})();\nCharacterString.NAME = "CharacterString";\nvar _a$6;\nvar UTCTime = class extends VisibleString {\n  constructor({ value, valueDate, ...parameters } = {}) {\n    super(parameters);\n    this.year = 0;\n    this.month = 0;\n    this.day = 0;\n    this.hour = 0;\n    this.minute = 0;\n    this.second = 0;\n    if (value) {\n      this.fromString(value);\n      this.valueBlock.valueHexView = new Uint8Array(value.length);\n      for (let i = 0; i < value.length; i++)\n        this.valueBlock.valueHexView[i] = value.charCodeAt(i);\n    }\n    if (valueDate) {\n      this.fromDate(valueDate);\n      this.valueBlock.valueHexView = new Uint8Array(this.toBuffer());\n    }\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 23;\n  }\n  fromBuffer(inputBuffer) {\n    this.fromString(String.fromCharCode.apply(null, BufferSourceConverter.toUint8Array(inputBuffer)));\n  }\n  toBuffer() {\n    const str = this.toString();\n    const buffer = new ArrayBuffer(str.length);\n    const view = new Uint8Array(buffer);\n    for (let i = 0; i < str.length; i++)\n      view[i] = str.charCodeAt(i);\n    return buffer;\n  }\n  fromDate(inputDate) {\n    this.year = inputDate.getUTCFullYear();\n    this.month = inputDate.getUTCMonth() + 1;\n    this.day = inputDate.getUTCDate();\n    this.hour = inputDate.getUTCHours();\n    this.minute = inputDate.getUTCMinutes();\n    this.second = inputDate.getUTCSeconds();\n  }\n  toDate() {\n    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second));\n  }\n  fromString(inputString) {\n    const parser = /(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})Z/ig;\n    const parserArray = parser.exec(inputString);\n    if (parserArray === null) {\n      this.error = "Wrong input string for conversion";\n      return;\n    }\n    const year = parseInt(parserArray[1], 10);\n    if (year >= 50)\n      this.year = 1900 + year;\n    else\n      this.year = 2e3 + year;\n    this.month = parseInt(parserArray[2], 10);\n    this.day = parseInt(parserArray[3], 10);\n    this.hour = parseInt(parserArray[4], 10);\n    this.minute = parseInt(parserArray[5], 10);\n    this.second = parseInt(parserArray[6], 10);\n  }\n  toString(encoding = "iso") {\n    if (encoding === "iso") {\n      const outputArray = new Array(7);\n      outputArray[0] = padNumber(this.year < 2e3 ? this.year - 1900 : this.year - 2e3, 2);\n      outputArray[1] = padNumber(this.month, 2);\n      outputArray[2] = padNumber(this.day, 2);\n      outputArray[3] = padNumber(this.hour, 2);\n      outputArray[4] = padNumber(this.minute, 2);\n      outputArray[5] = padNumber(this.second, 2);\n      outputArray[6] = "Z";\n      return outputArray.join("");\n    }\n    return super.toString(encoding);\n  }\n  onAsciiEncoding() {\n    return `${this.constructor.NAME} : ${this.toDate().toISOString()}`;\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      year: this.year,\n      month: this.month,\n      day: this.day,\n      hour: this.hour,\n      minute: this.minute,\n      second: this.second\n    };\n  }\n};\n__name(UTCTime, "UTCTime");\n_a$6 = UTCTime;\n(() => {\n  typeStore.UTCTime = _a$6;\n})();\nUTCTime.NAME = "UTCTime";\nvar _a$5;\nvar GeneralizedTime = class extends UTCTime {\n  constructor(parameters = {}) {\n    var _b;\n    super(parameters);\n    (_b = this.millisecond) !== null && _b !== void 0 ? _b : this.millisecond = 0;\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 24;\n  }\n  fromDate(inputDate) {\n    super.fromDate(inputDate);\n    this.millisecond = inputDate.getUTCMilliseconds();\n  }\n  toDate() {\n    return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond));\n  }\n  fromString(inputString) {\n    let isUTC = false;\n    let timeString = "";\n    let dateTimeString = "";\n    let fractionPart = 0;\n    let parser;\n    let hourDifference = 0;\n    let minuteDifference = 0;\n    if (inputString[inputString.length - 1] === "Z") {\n      timeString = inputString.substring(0, inputString.length - 1);\n      isUTC = true;\n    } else {\n      const number = new Number(inputString[inputString.length - 1]);\n      if (isNaN(number.valueOf()))\n        throw new Error("Wrong input string for conversion");\n      timeString = inputString;\n    }\n    if (isUTC) {\n      if (timeString.indexOf("+") !== -1)\n        throw new Error("Wrong input string for conversion");\n      if (timeString.indexOf("-") !== -1)\n        throw new Error("Wrong input string for conversion");\n    } else {\n      let multiplier = 1;\n      let differencePosition = timeString.indexOf("+");\n      let differenceString = "";\n      if (differencePosition === -1) {\n        differencePosition = timeString.indexOf("-");\n        multiplier = -1;\n      }\n      if (differencePosition !== -1) {\n        differenceString = timeString.substring(differencePosition + 1);\n        timeString = timeString.substring(0, differencePosition);\n        if (differenceString.length !== 2 && differenceString.length !== 4)\n          throw new Error("Wrong input string for conversion");\n        let number = parseInt(differenceString.substring(0, 2), 10);\n        if (isNaN(number.valueOf()))\n          throw new Error("Wrong input string for conversion");\n        hourDifference = multiplier * number;\n        if (differenceString.length === 4) {\n          number = parseInt(differenceString.substring(2, 4), 10);\n          if (isNaN(number.valueOf()))\n            throw new Error("Wrong input string for conversion");\n          minuteDifference = multiplier * number;\n        }\n      }\n    }\n    let fractionPointPosition = timeString.indexOf(".");\n    if (fractionPointPosition === -1)\n      fractionPointPosition = timeString.indexOf(",");\n    if (fractionPointPosition !== -1) {\n      const fractionPartCheck = new Number(`0${timeString.substring(fractionPointPosition)}`);\n      if (isNaN(fractionPartCheck.valueOf()))\n        throw new Error("Wrong input string for conversion");\n      fractionPart = fractionPartCheck.valueOf();\n      dateTimeString = timeString.substring(0, fractionPointPosition);\n    } else\n      dateTimeString = timeString;\n    switch (true) {\n      case dateTimeString.length === 8:\n        parser = /(\\d{4})(\\d{2})(\\d{2})/ig;\n        if (fractionPointPosition !== -1)\n          throw new Error("Wrong input string for conversion");\n        break;\n      case dateTimeString.length === 10:\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})/ig;\n        if (fractionPointPosition !== -1) {\n          let fractionResult = 60 * fractionPart;\n          this.minute = Math.floor(fractionResult);\n          fractionResult = 60 * (fractionResult - this.minute);\n          this.second = Math.floor(fractionResult);\n          fractionResult = 1e3 * (fractionResult - this.second);\n          this.millisecond = Math.floor(fractionResult);\n        }\n        break;\n      case dateTimeString.length === 12:\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n        if (fractionPointPosition !== -1) {\n          let fractionResult = 60 * fractionPart;\n          this.second = Math.floor(fractionResult);\n          fractionResult = 1e3 * (fractionResult - this.second);\n          this.millisecond = Math.floor(fractionResult);\n        }\n        break;\n      case dateTimeString.length === 14:\n        parser = /(\\d{4})(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})/ig;\n        if (fractionPointPosition !== -1) {\n          const fractionResult = 1e3 * fractionPart;\n          this.millisecond = Math.floor(fractionResult);\n        }\n        break;\n      default:\n        throw new Error("Wrong input string for conversion");\n    }\n    const parserArray = parser.exec(dateTimeString);\n    if (parserArray === null)\n      throw new Error("Wrong input string for conversion");\n    for (let j = 1; j < parserArray.length; j++) {\n      switch (j) {\n        case 1:\n          this.year = parseInt(parserArray[j], 10);\n          break;\n        case 2:\n          this.month = parseInt(parserArray[j], 10);\n          break;\n        case 3:\n          this.day = parseInt(parserArray[j], 10);\n          break;\n        case 4:\n          this.hour = parseInt(parserArray[j], 10) + hourDifference;\n          break;\n        case 5:\n          this.minute = parseInt(parserArray[j], 10) + minuteDifference;\n          break;\n        case 6:\n          this.second = parseInt(parserArray[j], 10);\n          break;\n        default:\n          throw new Error("Wrong input string for conversion");\n      }\n    }\n    if (isUTC === false) {\n      const tempDate = new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);\n      this.year = tempDate.getUTCFullYear();\n      this.month = tempDate.getUTCMonth();\n      this.day = tempDate.getUTCDay();\n      this.hour = tempDate.getUTCHours();\n      this.minute = tempDate.getUTCMinutes();\n      this.second = tempDate.getUTCSeconds();\n      this.millisecond = tempDate.getUTCMilliseconds();\n    }\n  }\n  toString(encoding = "iso") {\n    if (encoding === "iso") {\n      const outputArray = [];\n      outputArray.push(padNumber(this.year, 4));\n      outputArray.push(padNumber(this.month, 2));\n      outputArray.push(padNumber(this.day, 2));\n      outputArray.push(padNumber(this.hour, 2));\n      outputArray.push(padNumber(this.minute, 2));\n      outputArray.push(padNumber(this.second, 2));\n      if (this.millisecond !== 0) {\n        outputArray.push(".");\n        outputArray.push(padNumber(this.millisecond, 3));\n      }\n      outputArray.push("Z");\n      return outputArray.join("");\n    }\n    return super.toString(encoding);\n  }\n  toJSON() {\n    return {\n      ...super.toJSON(),\n      millisecond: this.millisecond\n    };\n  }\n};\n__name(GeneralizedTime, "GeneralizedTime");\n_a$5 = GeneralizedTime;\n(() => {\n  typeStore.GeneralizedTime = _a$5;\n})();\nGeneralizedTime.NAME = "GeneralizedTime";\nvar _a$4;\nvar DATE = class extends Utf8String {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 31;\n  }\n};\n__name(DATE, "DATE");\n_a$4 = DATE;\n(() => {\n  typeStore.DATE = _a$4;\n})();\nDATE.NAME = "DATE";\nvar _a$3;\nvar TimeOfDay = class extends Utf8String {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 32;\n  }\n};\n__name(TimeOfDay, "TimeOfDay");\n_a$3 = TimeOfDay;\n(() => {\n  typeStore.TimeOfDay = _a$3;\n})();\nTimeOfDay.NAME = "TimeOfDay";\nvar _a$2;\nvar DateTime = class extends Utf8String {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 33;\n  }\n};\n__name(DateTime, "DateTime");\n_a$2 = DateTime;\n(() => {\n  typeStore.DateTime = _a$2;\n})();\nDateTime.NAME = "DateTime";\nvar _a$1;\nvar Duration = class extends Utf8String {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 34;\n  }\n};\n__name(Duration, "Duration");\n_a$1 = Duration;\n(() => {\n  typeStore.Duration = _a$1;\n})();\nDuration.NAME = "Duration";\nvar _a;\nvar TIME = class extends Utf8String {\n  constructor(parameters = {}) {\n    super(parameters);\n    this.idBlock.tagClass = 1;\n    this.idBlock.tagNumber = 14;\n  }\n};\n__name(TIME, "TIME");\n_a = TIME;\n(() => {\n  typeStore.TIME = _a;\n})();\nTIME.NAME = "TIME";\nvar Any = class {\n  constructor({ name = EMPTY_STRING, optional = false } = {}) {\n    this.name = name;\n    this.optional = optional;\n  }\n};\n__name(Any, "Any");\nvar Choice = class extends Any {\n  constructor({ value = [], ...parameters } = {}) {\n    super(parameters);\n    this.value = value;\n  }\n};\n__name(Choice, "Choice");\nvar Repeated = class extends Any {\n  constructor({ value = new Any(), local = false, ...parameters } = {}) {\n    super(parameters);\n    this.value = value;\n    this.local = local;\n  }\n};\n__name(Repeated, "Repeated");\nvar RawData = class {\n  constructor({ data = EMPTY_VIEW } = {}) {\n    this.dataView = BufferSourceConverter.toUint8Array(data);\n  }\n  get data() {\n    return this.dataView.slice().buffer;\n  }\n  set data(value) {\n    this.dataView = BufferSourceConverter.toUint8Array(value);\n  }\n  fromBER(inputBuffer, inputOffset, inputLength) {\n    const endLength = inputOffset + inputLength;\n    this.dataView = BufferSourceConverter.toUint8Array(inputBuffer).subarray(inputOffset, endLength);\n    return endLength;\n  }\n  toBER(sizeOnly) {\n    return this.dataView.slice().buffer;\n  }\n};\n__name(RawData, "RawData");\nfunction compareSchema(root, inputData, inputSchema) {\n  if (inputSchema instanceof Choice) {\n    for (let j = 0; j < inputSchema.value.length; j++) {\n      const result = compareSchema(root, inputData, inputSchema.value[j]);\n      if (result.verified) {\n        return {\n          verified: true,\n          result: root\n        };\n      }\n    }\n    {\n      const _result = {\n        verified: false,\n        result: {\n          error: "Wrong values for Choice type"\n        }\n      };\n      if (inputSchema.hasOwnProperty(NAME))\n        _result.name = inputSchema.name;\n      return _result;\n    }\n  }\n  if (inputSchema instanceof Any) {\n    if (inputSchema.hasOwnProperty(NAME))\n      root[inputSchema.name] = inputData;\n    return {\n      verified: true,\n      result: root\n    };\n  }\n  if (root instanceof Object === false) {\n    return {\n      verified: false,\n      result: { error: "Wrong root object" }\n    };\n  }\n  if (inputData instanceof Object === false) {\n    return {\n      verified: false,\n      result: { error: "Wrong ASN.1 data" }\n    };\n  }\n  if (inputSchema instanceof Object === false) {\n    return {\n      verified: false,\n      result: { error: "Wrong ASN.1 schema" }\n    };\n  }\n  if (ID_BLOCK in inputSchema === false) {\n    return {\n      verified: false,\n      result: { error: "Wrong ASN.1 schema" }\n    };\n  }\n  if (FROM_BER in inputSchema.idBlock === false) {\n    return {\n      verified: false,\n      result: { error: "Wrong ASN.1 schema" }\n    };\n  }\n  if (TO_BER in inputSchema.idBlock === false) {\n    return {\n      verified: false,\n      result: { error: "Wrong ASN.1 schema" }\n    };\n  }\n  const encodedId = inputSchema.idBlock.toBER(false);\n  if (encodedId.byteLength === 0) {\n    return {\n      verified: false,\n      result: { error: "Error encoding idBlock for ASN.1 schema" }\n    };\n  }\n  const decodedOffset = inputSchema.idBlock.fromBER(encodedId, 0, encodedId.byteLength);\n  if (decodedOffset === -1) {\n    return {\n      verified: false,\n      result: { error: "Error decoding idBlock for ASN.1 schema" }\n    };\n  }\n  if (inputSchema.idBlock.hasOwnProperty(TAG_CLASS) === false) {\n    return {\n      verified: false,\n      result: { error: "Wrong ASN.1 schema" }\n    };\n  }\n  if (inputSchema.idBlock.tagClass !== inputData.idBlock.tagClass) {\n    return {\n      verified: false,\n      result: root\n    };\n  }\n  if (inputSchema.idBlock.hasOwnProperty(TAG_NUMBER) === false) {\n    return {\n      verified: false,\n      result: { error: "Wrong ASN.1 schema" }\n    };\n  }\n  if (inputSchema.idBlock.tagNumber !== inputData.idBlock.tagNumber) {\n    return {\n      verified: false,\n      result: root\n    };\n  }\n  if (inputSchema.idBlock.hasOwnProperty(IS_CONSTRUCTED) === false) {\n    return {\n      verified: false,\n      result: { error: "Wrong ASN.1 schema" }\n    };\n  }\n  if (inputSchema.idBlock.isConstructed !== inputData.idBlock.isConstructed) {\n    return {\n      verified: false,\n      result: root\n    };\n  }\n  if (!(IS_HEX_ONLY in inputSchema.idBlock)) {\n    return {\n      verified: false,\n      result: { error: "Wrong ASN.1 schema" }\n    };\n  }\n  if (inputSchema.idBlock.isHexOnly !== inputData.idBlock.isHexOnly) {\n    return {\n      verified: false,\n      result: root\n    };\n  }\n  if (inputSchema.idBlock.isHexOnly) {\n    if (VALUE_HEX_VIEW in inputSchema.idBlock === false) {\n      return {\n        verified: false,\n        result: { error: "Wrong ASN.1 schema" }\n      };\n    }\n    const schemaView = inputSchema.idBlock.valueHexView;\n    const asn1View = inputData.idBlock.valueHexView;\n    if (schemaView.length !== asn1View.length) {\n      return {\n        verified: false,\n        result: root\n      };\n    }\n    for (let i = 0; i < schemaView.length; i++) {\n      if (schemaView[i] !== asn1View[1]) {\n        return {\n          verified: false,\n          result: root\n        };\n      }\n    }\n  }\n  if (inputSchema.name) {\n    inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n    if (inputSchema.name)\n      root[inputSchema.name] = inputData;\n  }\n  if (inputSchema instanceof typeStore.Constructed) {\n    let admission = 0;\n    let result = {\n      verified: false,\n      result: {\n        error: "Unknown error"\n      }\n    };\n    let maxLength = inputSchema.valueBlock.value.length;\n    if (maxLength > 0) {\n      if (inputSchema.valueBlock.value[0] instanceof Repeated) {\n        maxLength = inputData.valueBlock.value.length;\n      }\n    }\n    if (maxLength === 0) {\n      return {\n        verified: true,\n        result: root\n      };\n    }\n    if (inputData.valueBlock.value.length === 0 && inputSchema.valueBlock.value.length !== 0) {\n      let _optional = true;\n      for (let i = 0; i < inputSchema.valueBlock.value.length; i++)\n        _optional = _optional && (inputSchema.valueBlock.value[i].optional || false);\n      if (_optional) {\n        return {\n          verified: true,\n          result: root\n        };\n      }\n      if (inputSchema.name) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n        if (inputSchema.name)\n          delete root[inputSchema.name];\n      }\n      root.error = "Inconsistent object length";\n      return {\n        verified: false,\n        result: root\n      };\n    }\n    for (let i = 0; i < maxLength; i++) {\n      if (i - admission >= inputData.valueBlock.value.length) {\n        if (inputSchema.valueBlock.value[i].optional === false) {\n          const _result = {\n            verified: false,\n            result: root\n          };\n          root.error = "Inconsistent length between ASN.1 data and schema";\n          if (inputSchema.name) {\n            inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n            if (inputSchema.name) {\n              delete root[inputSchema.name];\n              _result.name = inputSchema.name;\n            }\n          }\n          return _result;\n        }\n      } else {\n        if (inputSchema.valueBlock.value[0] instanceof Repeated) {\n          result = compareSchema(root, inputData.valueBlock.value[i], inputSchema.valueBlock.value[0].value);\n          if (result.verified === false) {\n            if (inputSchema.valueBlock.value[0].optional)\n              admission++;\n            else {\n              if (inputSchema.name) {\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                if (inputSchema.name)\n                  delete root[inputSchema.name];\n              }\n              return result;\n            }\n          }\n          if (NAME in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].name.length > 0) {\n            let arrayRoot = {};\n            if (LOCAL in inputSchema.valueBlock.value[0] && inputSchema.valueBlock.value[0].local)\n              arrayRoot = inputData;\n            else\n              arrayRoot = root;\n            if (typeof arrayRoot[inputSchema.valueBlock.value[0].name] === "undefined")\n              arrayRoot[inputSchema.valueBlock.value[0].name] = [];\n            arrayRoot[inputSchema.valueBlock.value[0].name].push(inputData.valueBlock.value[i]);\n          }\n        } else {\n          result = compareSchema(root, inputData.valueBlock.value[i - admission], inputSchema.valueBlock.value[i]);\n          if (result.verified === false) {\n            if (inputSchema.valueBlock.value[i].optional)\n              admission++;\n            else {\n              if (inputSchema.name) {\n                inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n                if (inputSchema.name)\n                  delete root[inputSchema.name];\n              }\n              return result;\n            }\n          }\n        }\n      }\n    }\n    if (result.verified === false) {\n      const _result = {\n        verified: false,\n        result: root\n      };\n      if (inputSchema.name) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n        if (inputSchema.name) {\n          delete root[inputSchema.name];\n          _result.name = inputSchema.name;\n        }\n      }\n      return _result;\n    }\n    return {\n      verified: true,\n      result: root\n    };\n  }\n  if (inputSchema.primitiveSchema && VALUE_HEX_VIEW in inputData.valueBlock) {\n    const asn1 = localFromBER(inputData.valueBlock.valueHexView);\n    if (asn1.offset === -1) {\n      const _result = {\n        verified: false,\n        result: asn1.result\n      };\n      if (inputSchema.name) {\n        inputSchema.name = inputSchema.name.replace(/^\\s+|\\s+$/g, EMPTY_STRING);\n        if (inputSchema.name) {\n          delete root[inputSchema.name];\n          _result.name = inputSchema.name;\n        }\n      }\n      return _result;\n    }\n    return compareSchema(root, asn1.result, inputSchema.primitiveSchema);\n  }\n  return {\n    verified: true,\n    result: root\n  };\n}\n__name(compareSchema, "compareSchema");\nfunction verifySchema(inputBuffer, inputSchema) {\n  if (inputSchema instanceof Object === false) {\n    return {\n      verified: false,\n      result: { error: "Wrong ASN.1 schema type" }\n    };\n  }\n  const asn1 = localFromBER(BufferSourceConverter.toUint8Array(inputBuffer));\n  if (asn1.offset === -1) {\n    return {\n      verified: false,\n      result: asn1.result\n    };\n  }\n  return compareSchema(asn1.result, asn1.result, inputSchema);\n}\n__name(verifySchema, "verifySchema");\n\n// ../../node_modules/.pnpm/@peculiar+asn1-schema@2.3.6/node_modules/@peculiar/asn1-schema/build/es2015/enums.js\nvar AsnTypeTypes;\n(function(AsnTypeTypes2) {\n  AsnTypeTypes2[AsnTypeTypes2["Sequence"] = 0] = "Sequence";\n  AsnTypeTypes2[AsnTypeTypes2["Set"] = 1] = "Set";\n  AsnTypeTypes2[AsnTypeTypes2["Choice"] = 2] = "Choice";\n})(AsnTypeTypes || (AsnTypeTypes = {}));\nvar AsnPropTypes;\n(function(AsnPropTypes2) {\n  AsnPropTypes2[AsnPropTypes2["Any"] = 1] = "Any";\n  AsnPropTypes2[AsnPropTypes2["Boolean"] = 2] = "Boolean";\n  AsnPropTypes2[AsnPropTypes2["OctetString"] = 3] = "OctetString";\n  AsnPropTypes2[AsnPropTypes2["BitString"] = 4] = "BitString";\n  AsnPropTypes2[AsnPropTypes2["Integer"] = 5] = "Integer";\n  AsnPropTypes2[AsnPropTypes2["Enumerated"] = 6] = "Enumerated";\n  AsnPropTypes2[AsnPropTypes2["ObjectIdentifier"] = 7] = "ObjectIdentifier";\n  AsnPropTypes2[AsnPropTypes2["Utf8String"] = 8] = "Utf8String";\n  AsnPropTypes2[AsnPropTypes2["BmpString"] = 9] = "BmpString";\n  AsnPropTypes2[AsnPropTypes2["UniversalString"] = 10] = "UniversalString";\n  AsnPropTypes2[AsnPropTypes2["NumericString"] = 11] = "NumericString";\n  AsnPropTypes2[AsnPropTypes2["PrintableString"] = 12] = "PrintableString";\n  AsnPropTypes2[AsnPropTypes2["TeletexString"] = 13] = "TeletexString";\n  AsnPropTypes2[AsnPropTypes2["VideotexString"] = 14] = "VideotexString";\n  AsnPropTypes2[AsnPropTypes2["IA5String"] = 15] = "IA5String";\n  AsnPropTypes2[AsnPropTypes2["GraphicString"] = 16] = "GraphicString";\n  AsnPropTypes2[AsnPropTypes2["VisibleString"] = 17] = "VisibleString";\n  AsnPropTypes2[AsnPropTypes2["GeneralString"] = 18] = "GeneralString";\n  AsnPropTypes2[AsnPropTypes2["CharacterString"] = 19] = "CharacterString";\n  AsnPropTypes2[AsnPropTypes2["UTCTime"] = 20] = "UTCTime";\n  AsnPropTypes2[AsnPropTypes2["GeneralizedTime"] = 21] = "GeneralizedTime";\n  AsnPropTypes2[AsnPropTypes2["DATE"] = 22] = "DATE";\n  AsnPropTypes2[AsnPropTypes2["TimeOfDay"] = 23] = "TimeOfDay";\n  AsnPropTypes2[AsnPropTypes2["DateTime"] = 24] = "DateTime";\n  AsnPropTypes2[AsnPropTypes2["Duration"] = 25] = "Duration";\n  AsnPropTypes2[AsnPropTypes2["TIME"] = 26] = "TIME";\n  AsnPropTypes2[AsnPropTypes2["Null"] = 27] = "Null";\n})(AsnPropTypes || (AsnPropTypes = {}));\n\n// ../../node_modules/.pnpm/@peculiar+asn1-schema@2.3.6/node_modules/@peculiar/asn1-schema/build/es2015/converters.js\nvar AsnAnyConverter = {\n  fromASN: (value) => value instanceof Null ? null : value.valueBeforeDecodeView,\n  toASN: (value) => {\n    if (value === null) {\n      return new Null();\n    }\n    const schema = fromBER(value);\n    if (schema.result.error) {\n      throw new Error(schema.result.error);\n    }\n    return schema.result;\n  }\n};\nvar AsnIntegerConverter = {\n  fromASN: (value) => value.valueBlock.valueHexView.byteLength >= 4 ? value.valueBlock.toString() : value.valueBlock.valueDec,\n  toASN: (value) => new Integer({ value: +value })\n};\nvar AsnEnumeratedConverter = {\n  fromASN: (value) => value.valueBlock.valueDec,\n  toASN: (value) => new Enumerated({ value })\n};\nvar AsnBitStringConverter = {\n  fromASN: (value) => value.valueBlock.valueHexView,\n  toASN: (value) => new BitString({ valueHex: value })\n};\nvar AsnObjectIdentifierConverter = {\n  fromASN: (value) => value.valueBlock.toString(),\n  toASN: (value) => new ObjectIdentifier({ value })\n};\nvar AsnBooleanConverter = {\n  fromASN: (value) => value.valueBlock.value,\n  toASN: (value) => new Boolean({ value })\n};\nvar AsnOctetStringConverter = {\n  fromASN: (value) => value.valueBlock.valueHexView,\n  toASN: (value) => new OctetString({ valueHex: value })\n};\nfunction createStringConverter(Asn1Type) {\n  return {\n    fromASN: (value) => value.valueBlock.value,\n    toASN: (value) => new Asn1Type({ value })\n  };\n}\n__name(createStringConverter, "createStringConverter");\nvar AsnUtf8StringConverter = createStringConverter(Utf8String);\nvar AsnBmpStringConverter = createStringConverter(BmpString);\nvar AsnUniversalStringConverter = createStringConverter(UniversalString);\nvar AsnNumericStringConverter = createStringConverter(NumericString);\nvar AsnPrintableStringConverter = createStringConverter(PrintableString);\nvar AsnTeletexStringConverter = createStringConverter(TeletexString);\nvar AsnVideotexStringConverter = createStringConverter(VideotexString);\nvar AsnIA5StringConverter = createStringConverter(IA5String);\nvar AsnGraphicStringConverter = createStringConverter(GraphicString);\nvar AsnVisibleStringConverter = createStringConverter(VisibleString);\nvar AsnGeneralStringConverter = createStringConverter(GeneralString);\nvar AsnCharacterStringConverter = createStringConverter(CharacterString);\nvar AsnUTCTimeConverter = {\n  fromASN: (value) => value.toDate(),\n  toASN: (value) => new UTCTime({ valueDate: value })\n};\nvar AsnGeneralizedTimeConverter = {\n  fromASN: (value) => value.toDate(),\n  toASN: (value) => new GeneralizedTime({ valueDate: value })\n};\nvar AsnNullConverter = {\n  fromASN: () => null,\n  toASN: () => {\n    return new Null();\n  }\n};\nfunction defaultConverter(type) {\n  switch (type) {\n    case AsnPropTypes.Any:\n      return AsnAnyConverter;\n    case AsnPropTypes.BitString:\n      return AsnBitStringConverter;\n    case AsnPropTypes.BmpString:\n      return AsnBmpStringConverter;\n    case AsnPropTypes.Boolean:\n      return AsnBooleanConverter;\n    case AsnPropTypes.CharacterString:\n      return AsnCharacterStringConverter;\n    case AsnPropTypes.Enumerated:\n      return AsnEnumeratedConverter;\n    case AsnPropTypes.GeneralString:\n      return AsnGeneralStringConverter;\n    case AsnPropTypes.GeneralizedTime:\n      return AsnGeneralizedTimeConverter;\n    case AsnPropTypes.GraphicString:\n      return AsnGraphicStringConverter;\n    case AsnPropTypes.IA5String:\n      return AsnIA5StringConverter;\n    case AsnPropTypes.Integer:\n      return AsnIntegerConverter;\n    case AsnPropTypes.Null:\n      return AsnNullConverter;\n    case AsnPropTypes.NumericString:\n      return AsnNumericStringConverter;\n    case AsnPropTypes.ObjectIdentifier:\n      return AsnObjectIdentifierConverter;\n    case AsnPropTypes.OctetString:\n      return AsnOctetStringConverter;\n    case AsnPropTypes.PrintableString:\n      return AsnPrintableStringConverter;\n    case AsnPropTypes.TeletexString:\n      return AsnTeletexStringConverter;\n    case AsnPropTypes.UTCTime:\n      return AsnUTCTimeConverter;\n    case AsnPropTypes.UniversalString:\n      return AsnUniversalStringConverter;\n    case AsnPropTypes.Utf8String:\n      return AsnUtf8StringConverter;\n    case AsnPropTypes.VideotexString:\n      return AsnVideotexStringConverter;\n    case AsnPropTypes.VisibleString:\n      return AsnVisibleStringConverter;\n    default:\n      return null;\n  }\n}\n__name(defaultConverter, "defaultConverter");\n\n// ../../node_modules/.pnpm/@peculiar+asn1-schema@2.3.6/node_modules/@peculiar/asn1-schema/build/es2015/helper.js\nfunction isConvertible(target) {\n  if (typeof target === "function" && target.prototype) {\n    if (target.prototype.toASN && target.prototype.fromASN) {\n      return true;\n    } else {\n      return isConvertible(target.prototype);\n    }\n  } else {\n    return !!(target && typeof target === "object" && "toASN" in target && "fromASN" in target);\n  }\n}\n__name(isConvertible, "isConvertible");\nfunction isTypeOfArray(target) {\n  var _a2;\n  if (target) {\n    const proto = Object.getPrototypeOf(target);\n    if (((_a2 = proto === null || proto === void 0 ? void 0 : proto.prototype) === null || _a2 === void 0 ? void 0 : _a2.constructor) === Array) {\n      return true;\n    }\n    return isTypeOfArray(proto);\n  }\n  return false;\n}\n__name(isTypeOfArray, "isTypeOfArray");\nfunction isArrayEqual(bytes1, bytes2) {\n  if (!(bytes1 && bytes2)) {\n    return false;\n  }\n  if (bytes1.byteLength !== bytes2.byteLength) {\n    return false;\n  }\n  const b1 = new Uint8Array(bytes1);\n  const b2 = new Uint8Array(bytes2);\n  for (let i = 0; i < bytes1.byteLength; i++) {\n    if (b1[i] !== b2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n__name(isArrayEqual, "isArrayEqual");\n\n// ../../node_modules/.pnpm/@peculiar+asn1-schema@2.3.6/node_modules/@peculiar/asn1-schema/build/es2015/schema.js\nvar AsnSchemaStorage = class {\n  constructor() {\n    this.items = /* @__PURE__ */ new WeakMap();\n  }\n  has(target) {\n    return this.items.has(target);\n  }\n  get(target, checkSchema = false) {\n    const schema = this.items.get(target);\n    if (!schema) {\n      throw new Error(`Cannot get schema for \'${target.prototype.constructor.name}\' target`);\n    }\n    if (checkSchema && !schema.schema) {\n      throw new Error(`Schema \'${target.prototype.constructor.name}\' doesn\'t contain ASN.1 schema. Call \'AsnSchemaStorage.cache\'.`);\n    }\n    return schema;\n  }\n  cache(target) {\n    const schema = this.get(target);\n    if (!schema.schema) {\n      schema.schema = this.create(target, true);\n    }\n  }\n  createDefault(target) {\n    const schema = {\n      type: AsnTypeTypes.Sequence,\n      items: {}\n    };\n    const parentSchema = this.findParentSchema(target);\n    if (parentSchema) {\n      Object.assign(schema, parentSchema);\n      schema.items = Object.assign({}, schema.items, parentSchema.items);\n    }\n    return schema;\n  }\n  create(target, useNames) {\n    const schema = this.items.get(target) || this.createDefault(target);\n    const asn1Value = [];\n    for (const key in schema.items) {\n      const item = schema.items[key];\n      const name = useNames ? key : "";\n      let asn1Item;\n      if (typeof item.type === "number") {\n        const Asn1TypeName = AsnPropTypes[item.type];\n        const Asn1Type = index_es_exports[Asn1TypeName];\n        if (!Asn1Type) {\n          throw new Error(`Cannot get ASN1 class by name \'${Asn1TypeName}\'`);\n        }\n        asn1Item = new Asn1Type({ name });\n      } else if (isConvertible(item.type)) {\n        const instance = new item.type();\n        asn1Item = instance.toSchema(name);\n      } else if (item.optional) {\n        const itemSchema = this.get(item.type);\n        if (itemSchema.type === AsnTypeTypes.Choice) {\n          asn1Item = new Any({ name });\n        } else {\n          asn1Item = this.create(item.type, false);\n          asn1Item.name = name;\n        }\n      } else {\n        asn1Item = new Any({ name });\n      }\n      const optional = !!item.optional || item.defaultValue !== void 0;\n      if (item.repeated) {\n        asn1Item.name = "";\n        const Container = item.repeated === "set" ? Set : Sequence;\n        asn1Item = new Container({\n          name: "",\n          value: [\n            new Repeated({\n              name,\n              value: asn1Item\n            })\n          ]\n        });\n      }\n      if (item.context !== null && item.context !== void 0) {\n        if (item.implicit) {\n          if (typeof item.type === "number" || isConvertible(item.type)) {\n            const Container = item.repeated ? Constructed : Primitive;\n            asn1Value.push(new Container({\n              name,\n              optional,\n              idBlock: {\n                tagClass: 3,\n                tagNumber: item.context\n              }\n            }));\n          } else {\n            this.cache(item.type);\n            const isRepeated = !!item.repeated;\n            let value = !isRepeated ? this.get(item.type, true).schema : asn1Item;\n            value = "valueBlock" in value ? value.valueBlock.value : value.value;\n            asn1Value.push(new Constructed({\n              name: !isRepeated ? name : "",\n              optional,\n              idBlock: {\n                tagClass: 3,\n                tagNumber: item.context\n              },\n              value\n            }));\n          }\n        } else {\n          asn1Value.push(new Constructed({\n            optional,\n            idBlock: {\n              tagClass: 3,\n              tagNumber: item.context\n            },\n            value: [asn1Item]\n          }));\n        }\n      } else {\n        asn1Item.optional = optional;\n        asn1Value.push(asn1Item);\n      }\n    }\n    switch (schema.type) {\n      case AsnTypeTypes.Sequence:\n        return new Sequence({ value: asn1Value, name: "" });\n      case AsnTypeTypes.Set:\n        return new Set({ value: asn1Value, name: "" });\n      case AsnTypeTypes.Choice:\n        return new Choice({ value: asn1Value, name: "" });\n      default:\n        throw new Error(`Unsupported ASN1 type in use`);\n    }\n  }\n  set(target, schema) {\n    this.items.set(target, schema);\n    return this;\n  }\n  findParentSchema(target) {\n    const parent = Object.getPrototypeOf(target);\n    if (parent) {\n      const schema = this.items.get(parent);\n      return schema || this.findParentSchema(parent);\n    }\n    return null;\n  }\n};\n__name(AsnSchemaStorage, "AsnSchemaStorage");\n\n// ../../node_modules/.pnpm/@peculiar+asn1-schema@2.3.6/node_modules/@peculiar/asn1-schema/build/es2015/storage.js\nvar schemaStorage = new AsnSchemaStorage();\n\n// ../../node_modules/.pnpm/@peculiar+asn1-schema@2.3.6/node_modules/@peculiar/asn1-schema/build/es2015/decorators.js\nvar AsnType = /* @__PURE__ */ __name((options) => (target) => {\n  let schema;\n  if (!schemaStorage.has(target)) {\n    schema = schemaStorage.createDefault(target);\n    schemaStorage.set(target, schema);\n  } else {\n    schema = schemaStorage.get(target);\n  }\n  Object.assign(schema, options);\n}, "AsnType");\nvar AsnProp = /* @__PURE__ */ __name((options) => (target, propertyKey) => {\n  let schema;\n  if (!schemaStorage.has(target.constructor)) {\n    schema = schemaStorage.createDefault(target.constructor);\n    schemaStorage.set(target.constructor, schema);\n  } else {\n    schema = schemaStorage.get(target.constructor);\n  }\n  const copyOptions = Object.assign({}, options);\n  if (typeof copyOptions.type === "number" && !copyOptions.converter) {\n    const defaultConverter2 = defaultConverter(options.type);\n    if (!defaultConverter2) {\n      throw new Error(`Cannot get default converter for property \'${propertyKey}\' of ${target.constructor.name}`);\n    }\n    copyOptions.converter = defaultConverter2;\n  }\n  schema.items[propertyKey] = copyOptions;\n}, "AsnProp");\n\n// ../../node_modules/.pnpm/@peculiar+asn1-schema@2.3.6/node_modules/@peculiar/asn1-schema/build/es2015/errors/schema_validation.js\nvar AsnSchemaValidationError = class extends Error {\n  constructor() {\n    super(...arguments);\n    this.schemas = [];\n  }\n};\n__name(AsnSchemaValidationError, "AsnSchemaValidationError");\n\n// ../../node_modules/.pnpm/@peculiar+asn1-schema@2.3.6/node_modules/@peculiar/asn1-schema/build/es2015/parser.js\nvar AsnParser = class {\n  static parse(data, target) {\n    const asn1Parsed = fromBER(data);\n    if (asn1Parsed.result.error) {\n      throw new Error(asn1Parsed.result.error);\n    }\n    const res = this.fromASN(asn1Parsed.result, target);\n    return res;\n  }\n  static fromASN(asn1Schema, target) {\n    var _a2;\n    try {\n      if (isConvertible(target)) {\n        const value = new target();\n        return value.fromASN(asn1Schema);\n      }\n      const schema = schemaStorage.get(target);\n      schemaStorage.cache(target);\n      let targetSchema = schema.schema;\n      if (asn1Schema.constructor === Constructed && schema.type !== AsnTypeTypes.Choice) {\n        targetSchema = new Constructed({\n          idBlock: {\n            tagClass: 3,\n            tagNumber: asn1Schema.idBlock.tagNumber\n          },\n          value: schema.schema.valueBlock.value\n        });\n        for (const key in schema.items) {\n          delete asn1Schema[key];\n        }\n      }\n      const asn1ComparedSchema = compareSchema({}, asn1Schema, targetSchema);\n      if (!asn1ComparedSchema.verified) {\n        throw new AsnSchemaValidationError(`Data does not match to ${target.name} ASN1 schema. ${asn1ComparedSchema.result.error}`);\n      }\n      const res = new target();\n      if (isTypeOfArray(target)) {\n        if (!("value" in asn1Schema.valueBlock && Array.isArray(asn1Schema.valueBlock.value))) {\n          throw new Error(`Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.`);\n        }\n        const itemType = schema.itemType;\n        if (typeof itemType === "number") {\n          const converter = defaultConverter(itemType);\n          if (!converter) {\n            throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n          }\n          return target.from(asn1Schema.valueBlock.value, (element) => converter.fromASN(element));\n        } else {\n          return target.from(asn1Schema.valueBlock.value, (element) => this.fromASN(element, itemType));\n        }\n      }\n      for (const key in schema.items) {\n        const asn1SchemaValue = asn1ComparedSchema.result[key];\n        if (!asn1SchemaValue) {\n          continue;\n        }\n        const schemaItem = schema.items[key];\n        const schemaItemType = schemaItem.type;\n        if (typeof schemaItemType === "number" || isConvertible(schemaItemType)) {\n          const converter = (_a2 = schemaItem.converter) !== null && _a2 !== void 0 ? _a2 : isConvertible(schemaItemType) ? new schemaItemType() : null;\n          if (!converter) {\n            throw new Error("Converter is empty");\n          }\n          if (schemaItem.repeated) {\n            if (schemaItem.implicit) {\n              const Container = schemaItem.repeated === "sequence" ? Sequence : Set;\n              const newItem = new Container();\n              newItem.valueBlock = asn1SchemaValue.valueBlock;\n              const newItemAsn = fromBER(newItem.toBER(false));\n              if (newItemAsn.offset === -1) {\n                throw new Error(`Cannot parse the child item. ${newItemAsn.result.error}`);\n              }\n              if (!("value" in newItemAsn.result.valueBlock && Array.isArray(newItemAsn.result.valueBlock.value))) {\n                throw new Error("Cannot get items from the ASN.1 parsed value. ASN.1 object is not constructed.");\n              }\n              const value = newItemAsn.result.valueBlock.value;\n              res[key] = Array.from(value, (element) => converter.fromASN(element));\n            } else {\n              res[key] = Array.from(asn1SchemaValue, (element) => converter.fromASN(element));\n            }\n          } else {\n            let value = asn1SchemaValue;\n            if (schemaItem.implicit) {\n              let newItem;\n              if (isConvertible(schemaItemType)) {\n                newItem = new schemaItemType().toSchema("");\n              } else {\n                const Asn1TypeName = AsnPropTypes[schemaItemType];\n                const Asn1Type = index_es_exports[Asn1TypeName];\n                if (!Asn1Type) {\n                  throw new Error(`Cannot get \'${Asn1TypeName}\' class from asn1js module`);\n                }\n                newItem = new Asn1Type();\n              }\n              newItem.valueBlock = value.valueBlock;\n              value = fromBER(newItem.toBER(false)).result;\n            }\n            res[key] = converter.fromASN(value);\n          }\n        } else {\n          if (schemaItem.repeated) {\n            if (!Array.isArray(asn1SchemaValue)) {\n              throw new Error("Cannot get list of items from the ASN.1 parsed value. ASN.1 value should be iterable.");\n            }\n            res[key] = Array.from(asn1SchemaValue, (element) => this.fromASN(element, schemaItemType));\n          } else {\n            res[key] = this.fromASN(asn1SchemaValue, schemaItemType);\n          }\n        }\n      }\n      return res;\n    } catch (error) {\n      if (error instanceof AsnSchemaValidationError) {\n        error.schemas.push(target.name);\n      }\n      throw error;\n    }\n  }\n};\n__name(AsnParser, "AsnParser");\n\n// ../../node_modules/.pnpm/@peculiar+asn1-schema@2.3.6/node_modules/@peculiar/asn1-schema/build/es2015/serializer.js\nvar AsnSerializer = class {\n  static serialize(obj) {\n    if (obj instanceof BaseBlock) {\n      return obj.toBER(false);\n    }\n    return this.toASN(obj).toBER(false);\n  }\n  static toASN(obj) {\n    if (obj && typeof obj === "object" && isConvertible(obj)) {\n      return obj.toASN();\n    }\n    if (!(obj && typeof obj === "object")) {\n      throw new TypeError("Parameter 1 should be type of Object.");\n    }\n    const target = obj.constructor;\n    const schema = schemaStorage.get(target);\n    schemaStorage.cache(target);\n    let asn1Value = [];\n    if (schema.itemType) {\n      if (!Array.isArray(obj)) {\n        throw new TypeError("Parameter 1 should be type of Array.");\n      }\n      if (typeof schema.itemType === "number") {\n        const converter = defaultConverter(schema.itemType);\n        if (!converter) {\n          throw new Error(`Cannot get default converter for array item of ${target.name} ASN1 schema`);\n        }\n        asn1Value = obj.map((o) => converter.toASN(o));\n      } else {\n        asn1Value = obj.map((o) => this.toAsnItem({ type: schema.itemType }, "[]", target, o));\n      }\n    } else {\n      for (const key in schema.items) {\n        const schemaItem = schema.items[key];\n        const objProp = obj[key];\n        if (objProp === void 0 || schemaItem.defaultValue === objProp || typeof schemaItem.defaultValue === "object" && typeof objProp === "object" && isArrayEqual(this.serialize(schemaItem.defaultValue), this.serialize(objProp))) {\n          continue;\n        }\n        const asn1Item = AsnSerializer.toAsnItem(schemaItem, key, target, objProp);\n        if (typeof schemaItem.context === "number") {\n          if (schemaItem.implicit) {\n            if (!schemaItem.repeated && (typeof schemaItem.type === "number" || isConvertible(schemaItem.type))) {\n              const value = {};\n              value.valueHex = asn1Item instanceof Null ? asn1Item.valueBeforeDecodeView : asn1Item.valueBlock.toBER();\n              asn1Value.push(new Primitive({\n                optional: schemaItem.optional,\n                idBlock: {\n                  tagClass: 3,\n                  tagNumber: schemaItem.context\n                },\n                ...value\n              }));\n            } else {\n              asn1Value.push(new Constructed({\n                optional: schemaItem.optional,\n                idBlock: {\n                  tagClass: 3,\n                  tagNumber: schemaItem.context\n                },\n                value: asn1Item.valueBlock.value\n              }));\n            }\n          } else {\n            asn1Value.push(new Constructed({\n              optional: schemaItem.optional,\n              idBlock: {\n                tagClass: 3,\n                tagNumber: schemaItem.context\n              },\n              value: [asn1Item]\n            }));\n          }\n        } else if (schemaItem.repeated) {\n          asn1Value = asn1Value.concat(asn1Item);\n        } else {\n          asn1Value.push(asn1Item);\n        }\n      }\n    }\n    let asnSchema;\n    switch (schema.type) {\n      case AsnTypeTypes.Sequence:\n        asnSchema = new Sequence({ value: asn1Value });\n        break;\n      case AsnTypeTypes.Set:\n        asnSchema = new Set({ value: asn1Value });\n        break;\n      case AsnTypeTypes.Choice:\n        if (!asn1Value[0]) {\n          throw new Error(`Schema \'${target.name}\' has wrong data. Choice cannot be empty.`);\n        }\n        asnSchema = asn1Value[0];\n        break;\n    }\n    return asnSchema;\n  }\n  static toAsnItem(schemaItem, key, target, objProp) {\n    let asn1Item;\n    if (typeof schemaItem.type === "number") {\n      const converter = schemaItem.converter;\n      if (!converter) {\n        throw new Error(`Property \'${key}\' doesn\'t have converter for type ${AsnPropTypes[schemaItem.type]} in schema \'${target.name}\'`);\n      }\n      if (schemaItem.repeated) {\n        if (!Array.isArray(objProp)) {\n          throw new TypeError("Parameter \'objProp\' should be type of Array.");\n        }\n        const items = Array.from(objProp, (element) => converter.toASN(element));\n        const Container = schemaItem.repeated === "sequence" ? Sequence : Set;\n        asn1Item = new Container({\n          value: items\n        });\n      } else {\n        asn1Item = converter.toASN(objProp);\n      }\n    } else {\n      if (schemaItem.repeated) {\n        if (!Array.isArray(objProp)) {\n          throw new TypeError("Parameter \'objProp\' should be type of Array.");\n        }\n        const items = Array.from(objProp, (element) => this.toASN(element));\n        const Container = schemaItem.repeated === "sequence" ? Sequence : Set;\n        asn1Item = new Container({\n          value: items\n        });\n      } else {\n        asn1Item = this.toASN(objProp);\n      }\n    }\n    return asn1Item;\n  }\n};\n__name(AsnSerializer, "AsnSerializer");\n\n// ../../node_modules/.pnpm/@peculiar+asn1-schema@2.3.6/node_modules/@peculiar/asn1-schema/build/es2015/convert.js\nvar AsnConvert = class {\n  static serialize(obj) {\n    return AsnSerializer.serialize(obj);\n  }\n  static parse(data, target) {\n    return AsnParser.parse(data, target);\n  }\n  static toString(data) {\n    const buf = BufferSourceConverter.isBufferSource(data) ? BufferSourceConverter.toArrayBuffer(data) : AsnConvert.serialize(data);\n    const asn = fromBER(buf);\n    if (asn.offset === -1) {\n      throw new Error(`Cannot decode ASN.1 data. ${asn.result.error}`);\n    }\n    return asn.result.toString();\n  }\n};\n__name(AsnConvert, "AsnConvert");\n\n// ../../node_modules/.pnpm/tslib@2.5.0/node_modules/tslib/tslib.es6.js\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")\n    r = Reflect.decorate(decorators, target, key, desc);\n  else\n    for (var i = decorators.length - 1; i >= 0; i--)\n      if (d = decorators[i])\n        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n__name(__decorate, "__decorate");\n\n// ../../node_modules/.pnpm/@peculiar+json-schema@1.1.12/node_modules/@peculiar/json-schema/build/index.es.js\nvar JsonError = class extends Error {\n  constructor(message, innerError) {\n    super(innerError ? `${message}. See the inner exception for more details.` : message);\n    this.message = message;\n    this.innerError = innerError;\n  }\n};\n__name(JsonError, "JsonError");\nvar TransformError = class extends JsonError {\n  constructor(schema, message, innerError) {\n    super(message, innerError);\n    this.schema = schema;\n  }\n};\n__name(TransformError, "TransformError");\nvar ParserError = class extends TransformError {\n  constructor(schema, message, innerError) {\n    super(schema, `JSON doesn\'t match to \'${schema.target.name}\' schema. ${message}`, innerError);\n  }\n};\n__name(ParserError, "ParserError");\nvar ValidationError = class extends JsonError {\n};\n__name(ValidationError, "ValidationError");\nvar SerializerError = class extends JsonError {\n  constructor(schemaName, message, innerError) {\n    super(`Cannot serialize by \'${schemaName}\' schema. ${message}`, innerError);\n    this.schemaName = schemaName;\n  }\n};\n__name(SerializerError, "SerializerError");\nvar KeyError = class extends ParserError {\n  constructor(schema, keys, errors = {}) {\n    super(schema, "Some keys doesn\'t match to schema");\n    this.keys = keys;\n    this.errors = errors;\n  }\n};\n__name(KeyError, "KeyError");\nvar JsonPropTypes;\n(function(JsonPropTypes2) {\n  JsonPropTypes2[JsonPropTypes2["Any"] = 0] = "Any";\n  JsonPropTypes2[JsonPropTypes2["Boolean"] = 1] = "Boolean";\n  JsonPropTypes2[JsonPropTypes2["Number"] = 2] = "Number";\n  JsonPropTypes2[JsonPropTypes2["String"] = 3] = "String";\n})(JsonPropTypes || (JsonPropTypes = {}));\nfunction checkType(value, type) {\n  switch (type) {\n    case JsonPropTypes.Boolean:\n      return typeof value === "boolean";\n    case JsonPropTypes.Number:\n      return typeof value === "number";\n    case JsonPropTypes.String:\n      return typeof value === "string";\n  }\n  return true;\n}\n__name(checkType, "checkType");\nfunction throwIfTypeIsWrong(value, type) {\n  if (!checkType(value, type)) {\n    throw new TypeError(`Value must be ${JsonPropTypes[type]}`);\n  }\n}\n__name(throwIfTypeIsWrong, "throwIfTypeIsWrong");\nfunction isConvertible2(target) {\n  if (target && target.prototype) {\n    if (target.prototype.toJSON && target.prototype.fromJSON) {\n      return true;\n    } else {\n      return isConvertible2(target.prototype);\n    }\n  } else {\n    return !!(target && target.toJSON && target.fromJSON);\n  }\n}\n__name(isConvertible2, "isConvertible");\nvar JsonSchemaStorage = class {\n  constructor() {\n    this.items = /* @__PURE__ */ new Map();\n  }\n  has(target) {\n    return this.items.has(target) || !!this.findParentSchema(target);\n  }\n  get(target) {\n    const schema = this.items.get(target) || this.findParentSchema(target);\n    if (!schema) {\n      throw new Error("Cannot get schema for current target");\n    }\n    return schema;\n  }\n  create(target) {\n    const schema = { names: {} };\n    const parentSchema = this.findParentSchema(target);\n    if (parentSchema) {\n      Object.assign(schema, parentSchema);\n      schema.names = {};\n      for (const name in parentSchema.names) {\n        schema.names[name] = Object.assign({}, parentSchema.names[name]);\n      }\n    }\n    schema.target = target;\n    return schema;\n  }\n  set(target, schema) {\n    this.items.set(target, schema);\n    return this;\n  }\n  findParentSchema(target) {\n    const parent = target.__proto__;\n    if (parent) {\n      const schema = this.items.get(parent);\n      return schema || this.findParentSchema(parent);\n    }\n    return null;\n  }\n};\n__name(JsonSchemaStorage, "JsonSchemaStorage");\nvar DEFAULT_SCHEMA = "default";\nvar schemaStorage2 = new JsonSchemaStorage();\nvar PatternValidation = class {\n  constructor(pattern) {\n    this.pattern = new RegExp(pattern);\n  }\n  validate(value) {\n    const pattern = new RegExp(this.pattern.source, this.pattern.flags);\n    if (typeof value !== "string") {\n      throw new ValidationError("Incoming value must be string");\n    }\n    if (!pattern.exec(value)) {\n      throw new ValidationError(`Value doesn\'t match to pattern \'${pattern.toString()}\'`);\n    }\n  }\n};\n__name(PatternValidation, "PatternValidation");\nvar InclusiveValidation = class {\n  constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {\n    this.min = min;\n    this.max = max;\n  }\n  validate(value) {\n    throwIfTypeIsWrong(value, JsonPropTypes.Number);\n    if (!(this.min <= value && value <= this.max)) {\n      const min = this.min === Number.MIN_VALUE ? "MIN" : this.min;\n      const max = this.max === Number.MAX_VALUE ? "MAX" : this.max;\n      throw new ValidationError(`Value doesn\'t match to diapason [${min},${max}]`);\n    }\n  }\n};\n__name(InclusiveValidation, "InclusiveValidation");\nvar ExclusiveValidation = class {\n  constructor(min = Number.MIN_VALUE, max = Number.MAX_VALUE) {\n    this.min = min;\n    this.max = max;\n  }\n  validate(value) {\n    throwIfTypeIsWrong(value, JsonPropTypes.Number);\n    if (!(this.min < value && value < this.max)) {\n      const min = this.min === Number.MIN_VALUE ? "MIN" : this.min;\n      const max = this.max === Number.MAX_VALUE ? "MAX" : this.max;\n      throw new ValidationError(`Value doesn\'t match to diapason (${min},${max})`);\n    }\n  }\n};\n__name(ExclusiveValidation, "ExclusiveValidation");\nvar LengthValidation = class {\n  constructor(length, minLength, maxLength) {\n    this.length = length;\n    this.minLength = minLength;\n    this.maxLength = maxLength;\n  }\n  validate(value) {\n    if (this.length !== void 0) {\n      if (value.length !== this.length) {\n        throw new ValidationError(`Value length must be exactly ${this.length}.`);\n      }\n      return;\n    }\n    if (this.minLength !== void 0) {\n      if (value.length < this.minLength) {\n        throw new ValidationError(`Value length must be more than ${this.minLength}.`);\n      }\n    }\n    if (this.maxLength !== void 0) {\n      if (value.length > this.maxLength) {\n        throw new ValidationError(`Value length must be less than ${this.maxLength}.`);\n      }\n    }\n  }\n};\n__name(LengthValidation, "LengthValidation");\nvar EnumerationValidation = class {\n  constructor(enumeration) {\n    this.enumeration = enumeration;\n  }\n  validate(value) {\n    throwIfTypeIsWrong(value, JsonPropTypes.String);\n    if (!this.enumeration.includes(value)) {\n      throw new ValidationError(`Value must be one of ${this.enumeration.map((v) => `\'${v}\'`).join(", ")}`);\n    }\n  }\n};\n__name(EnumerationValidation, "EnumerationValidation");\nvar JsonTransform = class {\n  static checkValues(data, schemaItem) {\n    const values = Array.isArray(data) ? data : [data];\n    for (const value of values) {\n      for (const validation of schemaItem.validations) {\n        if (validation instanceof LengthValidation && schemaItem.repeated) {\n          validation.validate(data);\n        } else {\n          validation.validate(value);\n        }\n      }\n    }\n  }\n  static checkTypes(value, schemaItem) {\n    if (schemaItem.repeated && !Array.isArray(value)) {\n      throw new TypeError("Value must be Array");\n    }\n    if (typeof schemaItem.type === "number") {\n      const values = Array.isArray(value) ? value : [value];\n      for (const v of values) {\n        throwIfTypeIsWrong(v, schemaItem.type);\n      }\n    }\n  }\n  static getSchemaByName(schema, name = DEFAULT_SCHEMA) {\n    return { ...schema.names[DEFAULT_SCHEMA], ...schema.names[name] };\n  }\n};\n__name(JsonTransform, "JsonTransform");\nvar JsonSerializer = class extends JsonTransform {\n  static serialize(obj, options, replacer, space) {\n    const json = this.toJSON(obj, options);\n    return JSON.stringify(json, replacer, space);\n  }\n  static toJSON(obj, options = {}) {\n    let res;\n    let targetSchema = options.targetSchema;\n    const schemaName = options.schemaName || DEFAULT_SCHEMA;\n    if (isConvertible2(obj)) {\n      return obj.toJSON();\n    }\n    if (Array.isArray(obj)) {\n      res = [];\n      for (const item of obj) {\n        res.push(this.toJSON(item, options));\n      }\n    } else if (typeof obj === "object") {\n      if (targetSchema && !schemaStorage2.has(targetSchema)) {\n        throw new JsonError("Cannot get schema for `targetSchema` param");\n      }\n      targetSchema = targetSchema || obj.constructor;\n      if (schemaStorage2.has(targetSchema)) {\n        const schema = schemaStorage2.get(targetSchema);\n        res = {};\n        const namedSchema = this.getSchemaByName(schema, schemaName);\n        for (const key in namedSchema) {\n          try {\n            const item = namedSchema[key];\n            const objItem = obj[key];\n            let value;\n            if (item.optional && objItem === void 0 || item.defaultValue !== void 0 && objItem === item.defaultValue) {\n              continue;\n            }\n            if (!item.optional && objItem === void 0) {\n              throw new SerializerError(targetSchema.name, `Property \'${key}\' is required.`);\n            }\n            if (typeof item.type === "number") {\n              if (item.converter) {\n                if (item.repeated) {\n                  value = objItem.map((el) => item.converter.toJSON(el, obj));\n                } else {\n                  value = item.converter.toJSON(objItem, obj);\n                }\n              } else {\n                value = objItem;\n              }\n            } else {\n              if (item.repeated) {\n                value = objItem.map((el) => this.toJSON(el, { schemaName }));\n              } else {\n                value = this.toJSON(objItem, { schemaName });\n              }\n            }\n            this.checkTypes(value, item);\n            this.checkValues(value, item);\n            res[item.name || key] = value;\n          } catch (e) {\n            if (e instanceof SerializerError) {\n              throw e;\n            } else {\n              throw new SerializerError(schema.target.name, `Property \'${key}\' is wrong. ${e.message}`, e);\n            }\n          }\n        }\n      } else {\n        res = {};\n        for (const key in obj) {\n          res[key] = this.toJSON(obj[key], { schemaName });\n        }\n      }\n    } else {\n      res = obj;\n    }\n    return res;\n  }\n};\n__name(JsonSerializer, "JsonSerializer");\nvar JsonParser = class extends JsonTransform {\n  static parse(data, options) {\n    const obj = JSON.parse(data);\n    return this.fromJSON(obj, options);\n  }\n  static fromJSON(target, options) {\n    const targetSchema = options.targetSchema;\n    const schemaName = options.schemaName || DEFAULT_SCHEMA;\n    const obj = new targetSchema();\n    if (isConvertible2(obj)) {\n      return obj.fromJSON(target);\n    }\n    const schema = schemaStorage2.get(targetSchema);\n    const namedSchema = this.getSchemaByName(schema, schemaName);\n    const keyErrors = {};\n    if (options.strictProperty && !Array.isArray(target)) {\n      JsonParser.checkStrictProperty(target, namedSchema, schema);\n    }\n    for (const key in namedSchema) {\n      try {\n        const item = namedSchema[key];\n        const name = item.name || key;\n        const value = target[name];\n        if (value === void 0 && (item.optional || item.defaultValue !== void 0)) {\n          continue;\n        }\n        if (!item.optional && value === void 0) {\n          throw new ParserError(schema, `Property \'${name}\' is required.`);\n        }\n        this.checkTypes(value, item);\n        this.checkValues(value, item);\n        if (typeof item.type === "number") {\n          if (item.converter) {\n            if (item.repeated) {\n              obj[key] = value.map((el) => item.converter.fromJSON(el, obj));\n            } else {\n              obj[key] = item.converter.fromJSON(value, obj);\n            }\n          } else {\n            obj[key] = value;\n          }\n        } else {\n          const newOptions = {\n            ...options,\n            targetSchema: item.type,\n            schemaName\n          };\n          if (item.repeated) {\n            obj[key] = value.map((el) => this.fromJSON(el, newOptions));\n          } else {\n            obj[key] = this.fromJSON(value, newOptions);\n          }\n        }\n      } catch (e) {\n        if (!(e instanceof ParserError)) {\n          e = new ParserError(schema, `Property \'${key}\' is wrong. ${e.message}`, e);\n        }\n        if (options.strictAllKeys) {\n          keyErrors[key] = e;\n        } else {\n          throw e;\n        }\n      }\n    }\n    const keys = Object.keys(keyErrors);\n    if (keys.length) {\n      throw new KeyError(schema, keys, keyErrors);\n    }\n    return obj;\n  }\n  static checkStrictProperty(target, namedSchema, schema) {\n    const jsonProps = Object.keys(target);\n    const schemaProps = Object.keys(namedSchema);\n    const keys = [];\n    for (const key of jsonProps) {\n      if (schemaProps.indexOf(key) === -1) {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      throw new KeyError(schema, keys);\n    }\n  }\n};\n__name(JsonParser, "JsonParser");\nfunction getValidations(item) {\n  const validations = [];\n  if (item.pattern) {\n    validations.push(new PatternValidation(item.pattern));\n  }\n  if (item.type === JsonPropTypes.Number || item.type === JsonPropTypes.Any) {\n    if (item.minInclusive !== void 0 || item.maxInclusive !== void 0) {\n      validations.push(new InclusiveValidation(item.minInclusive, item.maxInclusive));\n    }\n    if (item.minExclusive !== void 0 || item.maxExclusive !== void 0) {\n      validations.push(new ExclusiveValidation(item.minExclusive, item.maxExclusive));\n    }\n    if (item.enumeration !== void 0) {\n      validations.push(new EnumerationValidation(item.enumeration));\n    }\n  }\n  if (item.type === JsonPropTypes.String || item.repeated || item.type === JsonPropTypes.Any) {\n    if (item.length !== void 0 || item.minLength !== void 0 || item.maxLength !== void 0) {\n      validations.push(new LengthValidation(item.length, item.minLength, item.maxLength));\n    }\n  }\n  return validations;\n}\n__name(getValidations, "getValidations");\nvar JsonProp = /* @__PURE__ */ __name((options = {}) => (target, propertyKey) => {\n  const errorMessage = `Cannot set type for ${propertyKey} property of ${target.constructor.name} schema`;\n  let schema;\n  if (!schemaStorage2.has(target.constructor)) {\n    schema = schemaStorage2.create(target.constructor);\n    schemaStorage2.set(target.constructor, schema);\n  } else {\n    schema = schemaStorage2.get(target.constructor);\n    if (schema.target !== target.constructor) {\n      schema = schemaStorage2.create(target.constructor);\n      schemaStorage2.set(target.constructor, schema);\n    }\n  }\n  const defaultSchema = {\n    type: JsonPropTypes.Any,\n    validations: []\n  };\n  const copyOptions = Object.assign(defaultSchema, options);\n  copyOptions.validations = getValidations(copyOptions);\n  if (typeof copyOptions.type !== "number") {\n    if (!schemaStorage2.has(copyOptions.type) && !isConvertible2(copyOptions.type)) {\n      throw new Error(`${errorMessage}. Assigning type doesn\'t have schema.`);\n    }\n  }\n  let schemaNames;\n  if (Array.isArray(options.schema)) {\n    schemaNames = options.schema;\n  } else {\n    schemaNames = [options.schema || DEFAULT_SCHEMA];\n  }\n  for (const schemaName of schemaNames) {\n    if (!schema.names[schemaName]) {\n      schema.names[schemaName] = {};\n    }\n    const namedSchema = schema.names[schemaName];\n    namedSchema[propertyKey] = copyOptions;\n  }\n}, "JsonProp");\n\n// ../../node_modules/.pnpm/webcrypto-core@1.7.7/node_modules/webcrypto-core/build/webcrypto-core.es.js\nvar CryptoError = class extends Error {\n};\n__name(CryptoError, "CryptoError");\nvar AlgorithmError = class extends CryptoError {\n};\n__name(AlgorithmError, "AlgorithmError");\nvar UnsupportedOperationError = class extends CryptoError {\n  constructor(methodName) {\n    super(`Unsupported operation: ${methodName ? `${methodName}` : ""}`);\n  }\n};\n__name(UnsupportedOperationError, "UnsupportedOperationError");\nvar OperationError = class extends CryptoError {\n};\n__name(OperationError, "OperationError");\nvar RequiredPropertyError = class extends CryptoError {\n  constructor(propName) {\n    super(`${propName}: Missing required property`);\n  }\n};\n__name(RequiredPropertyError, "RequiredPropertyError");\nfunction isJWK(data) {\n  return typeof data === "object" && "kty" in data;\n}\n__name(isJWK, "isJWK");\nvar ProviderCrypto = class {\n  async digest(...args) {\n    this.checkDigest.apply(this, args);\n    return this.onDigest.apply(this, args);\n  }\n  checkDigest(algorithm, data) {\n    this.checkAlgorithmName(algorithm);\n  }\n  async onDigest(algorithm, data) {\n    throw new UnsupportedOperationError("digest");\n  }\n  async generateKey(...args) {\n    this.checkGenerateKey.apply(this, args);\n    return this.onGenerateKey.apply(this, args);\n  }\n  checkGenerateKey(algorithm, extractable, keyUsages, ...args) {\n    this.checkAlgorithmName(algorithm);\n    this.checkGenerateKeyParams(algorithm);\n    if (!(keyUsages && keyUsages.length)) {\n      throw new TypeError(`Usages cannot be empty when creating a key.`);\n    }\n    let allowedUsages;\n    if (Array.isArray(this.usages)) {\n      allowedUsages = this.usages;\n    } else {\n      allowedUsages = this.usages.privateKey.concat(this.usages.publicKey);\n    }\n    this.checkKeyUsages(keyUsages, allowedUsages);\n  }\n  checkGenerateKeyParams(algorithm) {\n  }\n  async onGenerateKey(algorithm, extractable, keyUsages, ...args) {\n    throw new UnsupportedOperationError("generateKey");\n  }\n  async sign(...args) {\n    this.checkSign.apply(this, args);\n    return this.onSign.apply(this, args);\n  }\n  checkSign(algorithm, key, data, ...args) {\n    this.checkAlgorithmName(algorithm);\n    this.checkAlgorithmParams(algorithm);\n    this.checkCryptoKey(key, "sign");\n  }\n  async onSign(algorithm, key, data, ...args) {\n    throw new UnsupportedOperationError("sign");\n  }\n  async verify(...args) {\n    this.checkVerify.apply(this, args);\n    return this.onVerify.apply(this, args);\n  }\n  checkVerify(algorithm, key, signature, data, ...args) {\n    this.checkAlgorithmName(algorithm);\n    this.checkAlgorithmParams(algorithm);\n    this.checkCryptoKey(key, "verify");\n  }\n  async onVerify(algorithm, key, signature, data, ...args) {\n    throw new UnsupportedOperationError("verify");\n  }\n  async encrypt(...args) {\n    this.checkEncrypt.apply(this, args);\n    return this.onEncrypt.apply(this, args);\n  }\n  checkEncrypt(algorithm, key, data, options = {}, ...args) {\n    this.checkAlgorithmName(algorithm);\n    this.checkAlgorithmParams(algorithm);\n    this.checkCryptoKey(key, options.keyUsage ? "encrypt" : void 0);\n  }\n  async onEncrypt(algorithm, key, data, ...args) {\n    throw new UnsupportedOperationError("encrypt");\n  }\n  async decrypt(...args) {\n    this.checkDecrypt.apply(this, args);\n    return this.onDecrypt.apply(this, args);\n  }\n  checkDecrypt(algorithm, key, data, options = {}, ...args) {\n    this.checkAlgorithmName(algorithm);\n    this.checkAlgorithmParams(algorithm);\n    this.checkCryptoKey(key, options.keyUsage ? "decrypt" : void 0);\n  }\n  async onDecrypt(algorithm, key, data, ...args) {\n    throw new UnsupportedOperationError("decrypt");\n  }\n  async deriveBits(...args) {\n    this.checkDeriveBits.apply(this, args);\n    return this.onDeriveBits.apply(this, args);\n  }\n  checkDeriveBits(algorithm, baseKey, length, options = {}, ...args) {\n    this.checkAlgorithmName(algorithm);\n    this.checkAlgorithmParams(algorithm);\n    this.checkCryptoKey(baseKey, options.keyUsage ? "deriveBits" : void 0);\n    if (length % 8 !== 0) {\n      throw new OperationError("length: Is not multiple of 8");\n    }\n  }\n  async onDeriveBits(algorithm, baseKey, length, ...args) {\n    throw new UnsupportedOperationError("deriveBits");\n  }\n  async exportKey(...args) {\n    this.checkExportKey.apply(this, args);\n    return this.onExportKey.apply(this, args);\n  }\n  checkExportKey(format, key, ...args) {\n    this.checkKeyFormat(format);\n    this.checkCryptoKey(key);\n    if (!key.extractable) {\n      throw new CryptoError("key: Is not extractable");\n    }\n  }\n  async onExportKey(format, key, ...args) {\n    throw new UnsupportedOperationError("exportKey");\n  }\n  async importKey(...args) {\n    this.checkImportKey.apply(this, args);\n    return this.onImportKey.apply(this, args);\n  }\n  checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n    this.checkKeyFormat(format);\n    this.checkKeyData(format, keyData);\n    this.checkAlgorithmName(algorithm);\n    this.checkImportParams(algorithm);\n    if (Array.isArray(this.usages)) {\n      this.checkKeyUsages(keyUsages, this.usages);\n    }\n  }\n  async onImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n    throw new UnsupportedOperationError("importKey");\n  }\n  checkAlgorithmName(algorithm) {\n    if (algorithm.name.toLowerCase() !== this.name.toLowerCase()) {\n      throw new AlgorithmError("Unrecognized name");\n    }\n  }\n  checkAlgorithmParams(algorithm) {\n  }\n  checkDerivedKeyParams(algorithm) {\n  }\n  checkKeyUsages(usages, allowed) {\n    for (const usage of usages) {\n      if (allowed.indexOf(usage) === -1) {\n        throw new TypeError("Cannot create a key using the specified key usages");\n      }\n    }\n  }\n  checkCryptoKey(key, keyUsage) {\n    this.checkAlgorithmName(key.algorithm);\n    if (keyUsage && key.usages.indexOf(keyUsage) === -1) {\n      throw new CryptoError(`key does not match that of operation`);\n    }\n  }\n  checkRequiredProperty(data, propName) {\n    if (!(propName in data)) {\n      throw new RequiredPropertyError(propName);\n    }\n  }\n  checkHashAlgorithm(algorithm, hashAlgorithms) {\n    for (const item of hashAlgorithms) {\n      if (item.toLowerCase() === algorithm.name.toLowerCase()) {\n        return;\n      }\n    }\n    throw new OperationError(`hash: Must be one of ${hashAlgorithms.join(", ")}`);\n  }\n  checkImportParams(algorithm) {\n  }\n  checkKeyFormat(format) {\n    switch (format) {\n      case "raw":\n      case "pkcs8":\n      case "spki":\n      case "jwk":\n        break;\n      default:\n        throw new TypeError("format: Is invalid value. Must be \'jwk\', \'raw\', \'spki\', or \'pkcs8\'");\n    }\n  }\n  checkKeyData(format, keyData) {\n    if (!keyData) {\n      throw new TypeError("keyData: Cannot be empty on empty on key importing");\n    }\n    if (format === "jwk") {\n      if (!isJWK(keyData)) {\n        throw new TypeError("keyData: Is not JsonWebToken");\n      }\n    } else if (!BufferSourceConverter.isBufferSource(keyData)) {\n      throw new TypeError("keyData: Is not ArrayBufferView or ArrayBuffer");\n    }\n  }\n  prepareData(data) {\n    return BufferSourceConverter.toArrayBuffer(data);\n  }\n};\n__name(ProviderCrypto, "ProviderCrypto");\nvar AesProvider = class extends ProviderCrypto {\n  checkGenerateKeyParams(algorithm) {\n    this.checkRequiredProperty(algorithm, "length");\n    if (typeof algorithm.length !== "number") {\n      throw new TypeError("length: Is not of type Number");\n    }\n    switch (algorithm.length) {\n      case 128:\n      case 192:\n      case 256:\n        break;\n      default:\n        throw new TypeError("length: Must be 128, 192, or 256");\n    }\n  }\n  checkDerivedKeyParams(algorithm) {\n    this.checkGenerateKeyParams(algorithm);\n  }\n};\n__name(AesProvider, "AesProvider");\nvar AesCbcProvider = class extends AesProvider {\n  constructor() {\n    super(...arguments);\n    this.name = "AES-CBC";\n    this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];\n  }\n  checkAlgorithmParams(algorithm) {\n    this.checkRequiredProperty(algorithm, "iv");\n    if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n      throw new TypeError("iv: Is not of type \'(ArrayBuffer or ArrayBufferView)\'");\n    }\n    if (algorithm.iv.byteLength !== 16) {\n      throw new TypeError("iv: Must have length 16 bytes");\n    }\n  }\n};\n__name(AesCbcProvider, "AesCbcProvider");\nvar AesCmacProvider = class extends AesProvider {\n  constructor() {\n    super(...arguments);\n    this.name = "AES-CMAC";\n    this.usages = ["sign", "verify"];\n  }\n  checkAlgorithmParams(algorithm) {\n    this.checkRequiredProperty(algorithm, "length");\n    if (typeof algorithm.length !== "number") {\n      throw new TypeError("length: Is not a Number");\n    }\n    if (algorithm.length < 1) {\n      throw new OperationError("length: Must be more than 0");\n    }\n  }\n};\n__name(AesCmacProvider, "AesCmacProvider");\nvar AesCtrProvider = class extends AesProvider {\n  constructor() {\n    super(...arguments);\n    this.name = "AES-CTR";\n    this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];\n  }\n  checkAlgorithmParams(algorithm) {\n    this.checkRequiredProperty(algorithm, "counter");\n    if (!(algorithm.counter instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.counter))) {\n      throw new TypeError("counter: Is not of type \'(ArrayBuffer or ArrayBufferView)\'");\n    }\n    if (algorithm.counter.byteLength !== 16) {\n      throw new TypeError("iv: Must have length 16 bytes");\n    }\n    this.checkRequiredProperty(algorithm, "length");\n    if (typeof algorithm.length !== "number") {\n      throw new TypeError("length: Is not a Number");\n    }\n    if (algorithm.length < 1) {\n      throw new OperationError("length: Must be more than 0");\n    }\n  }\n};\n__name(AesCtrProvider, "AesCtrProvider");\nvar AesEcbProvider = class extends AesProvider {\n  constructor() {\n    super(...arguments);\n    this.name = "AES-ECB";\n    this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];\n  }\n};\n__name(AesEcbProvider, "AesEcbProvider");\nvar AesGcmProvider = class extends AesProvider {\n  constructor() {\n    super(...arguments);\n    this.name = "AES-GCM";\n    this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];\n  }\n  checkAlgorithmParams(algorithm) {\n    this.checkRequiredProperty(algorithm, "iv");\n    if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n      throw new TypeError("iv: Is not of type \'(ArrayBuffer or ArrayBufferView)\'");\n    }\n    if (algorithm.iv.byteLength < 1) {\n      throw new OperationError("iv: Must have length more than 0 and less than 2^64 - 1");\n    }\n    if (!("tagLength" in algorithm)) {\n      algorithm.tagLength = 128;\n    }\n    switch (algorithm.tagLength) {\n      case 32:\n      case 64:\n      case 96:\n      case 104:\n      case 112:\n      case 120:\n      case 128:\n        break;\n      default:\n        throw new OperationError("tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128");\n    }\n  }\n};\n__name(AesGcmProvider, "AesGcmProvider");\nvar AesKwProvider = class extends AesProvider {\n  constructor() {\n    super(...arguments);\n    this.name = "AES-KW";\n    this.usages = ["wrapKey", "unwrapKey"];\n  }\n};\n__name(AesKwProvider, "AesKwProvider");\nvar DesProvider = class extends ProviderCrypto {\n  constructor() {\n    super(...arguments);\n    this.usages = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];\n  }\n  checkAlgorithmParams(algorithm) {\n    if (this.ivSize) {\n      this.checkRequiredProperty(algorithm, "iv");\n      if (!(algorithm.iv instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.iv))) {\n        throw new TypeError("iv: Is not of type \'(ArrayBuffer or ArrayBufferView)\'");\n      }\n      if (algorithm.iv.byteLength !== this.ivSize) {\n        throw new TypeError(`iv: Must have length ${this.ivSize} bytes`);\n      }\n    }\n  }\n  checkGenerateKeyParams(algorithm) {\n    this.checkRequiredProperty(algorithm, "length");\n    if (typeof algorithm.length !== "number") {\n      throw new TypeError("length: Is not of type Number");\n    }\n    if (algorithm.length !== this.keySizeBits) {\n      throw new OperationError(`algorithm.length: Must be ${this.keySizeBits}`);\n    }\n  }\n  checkDerivedKeyParams(algorithm) {\n    this.checkGenerateKeyParams(algorithm);\n  }\n};\n__name(DesProvider, "DesProvider");\nvar RsaProvider = class extends ProviderCrypto {\n  constructor() {\n    super(...arguments);\n    this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];\n  }\n  checkGenerateKeyParams(algorithm) {\n    this.checkRequiredProperty(algorithm, "hash");\n    this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    this.checkRequiredProperty(algorithm, "publicExponent");\n    if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {\n      throw new TypeError("publicExponent: Missing or not a Uint8Array");\n    }\n    const publicExponent = Convert.ToBase64(algorithm.publicExponent);\n    if (!(publicExponent === "Aw==" || publicExponent === "AQAB")) {\n      throw new TypeError("publicExponent: Must be [3] or [1,0,1]");\n    }\n    this.checkRequiredProperty(algorithm, "modulusLength");\n    if (algorithm.modulusLength % 8 || algorithm.modulusLength < 256 || algorithm.modulusLength > 16384) {\n      throw new TypeError("The modulus length must be a multiple of 8 bits and >= 256 and <= 16384");\n    }\n  }\n  checkImportParams(algorithm) {\n    this.checkRequiredProperty(algorithm, "hash");\n    this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n  }\n};\n__name(RsaProvider, "RsaProvider");\nvar RsaSsaProvider = class extends RsaProvider {\n  constructor() {\n    super(...arguments);\n    this.name = "RSASSA-PKCS1-v1_5";\n    this.usages = {\n      privateKey: ["sign"],\n      publicKey: ["verify"]\n    };\n  }\n};\n__name(RsaSsaProvider, "RsaSsaProvider");\nvar RsaPssProvider = class extends RsaProvider {\n  constructor() {\n    super(...arguments);\n    this.name = "RSA-PSS";\n    this.usages = {\n      privateKey: ["sign"],\n      publicKey: ["verify"]\n    };\n  }\n  checkAlgorithmParams(algorithm) {\n    this.checkRequiredProperty(algorithm, "saltLength");\n    if (typeof algorithm.saltLength !== "number") {\n      throw new TypeError("saltLength: Is not a Number");\n    }\n    if (algorithm.saltLength < 0) {\n      throw new RangeError("saltLength: Must be positive number");\n    }\n  }\n};\n__name(RsaPssProvider, "RsaPssProvider");\nvar RsaOaepProvider = class extends RsaProvider {\n  constructor() {\n    super(...arguments);\n    this.name = "RSA-OAEP";\n    this.usages = {\n      privateKey: ["decrypt", "unwrapKey"],\n      publicKey: ["encrypt", "wrapKey"]\n    };\n  }\n  checkAlgorithmParams(algorithm) {\n    if (algorithm.label && !(algorithm.label instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.label))) {\n      throw new TypeError("label: Is not of type \'(ArrayBuffer or ArrayBufferView)\'");\n    }\n  }\n};\n__name(RsaOaepProvider, "RsaOaepProvider");\nvar EllipticProvider = class extends ProviderCrypto {\n  checkGenerateKeyParams(algorithm) {\n    this.checkRequiredProperty(algorithm, "namedCurve");\n    this.checkNamedCurve(algorithm.namedCurve);\n  }\n  checkNamedCurve(namedCurve) {\n    for (const item of this.namedCurves) {\n      if (item.toLowerCase() === namedCurve.toLowerCase()) {\n        return;\n      }\n    }\n    throw new OperationError(`namedCurve: Must be one of ${this.namedCurves.join(", ")}`);\n  }\n};\n__name(EllipticProvider, "EllipticProvider");\nvar EcdsaProvider = class extends EllipticProvider {\n  constructor() {\n    super(...arguments);\n    this.name = "ECDSA";\n    this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];\n    this.usages = {\n      privateKey: ["sign"],\n      publicKey: ["verify"]\n    };\n    this.namedCurves = ["P-256", "P-384", "P-521", "K-256"];\n  }\n  checkAlgorithmParams(algorithm) {\n    this.checkRequiredProperty(algorithm, "hash");\n    this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n  }\n};\n__name(EcdsaProvider, "EcdsaProvider");\nvar KEY_TYPES = ["secret", "private", "public"];\nvar CryptoKey = class {\n  static create(algorithm, type, extractable, usages) {\n    const key = new this();\n    key.algorithm = algorithm;\n    key.type = type;\n    key.extractable = extractable;\n    key.usages = usages;\n    return key;\n  }\n  static isKeyType(data) {\n    return KEY_TYPES.indexOf(data) !== -1;\n  }\n  get [Symbol.toStringTag]() {\n    return "CryptoKey";\n  }\n};\n__name(CryptoKey, "CryptoKey");\nvar EcdhProvider = class extends EllipticProvider {\n  constructor() {\n    super(...arguments);\n    this.name = "ECDH";\n    this.usages = {\n      privateKey: ["deriveBits", "deriveKey"],\n      publicKey: []\n    };\n    this.namedCurves = ["P-256", "P-384", "P-521", "K-256"];\n  }\n  checkAlgorithmParams(algorithm) {\n    this.checkRequiredProperty(algorithm, "public");\n    if (!(algorithm.public instanceof CryptoKey)) {\n      throw new TypeError("public: Is not a CryptoKey");\n    }\n    if (algorithm.public.type !== "public") {\n      throw new OperationError("public: Is not a public key");\n    }\n    if (algorithm.public.algorithm.name !== this.name) {\n      throw new OperationError(`public: Is not ${this.name} key`);\n    }\n  }\n};\n__name(EcdhProvider, "EcdhProvider");\nvar EcdhEsProvider = class extends EcdhProvider {\n  constructor() {\n    super(...arguments);\n    this.name = "ECDH-ES";\n    this.namedCurves = ["X25519", "X448"];\n  }\n};\n__name(EcdhEsProvider, "EcdhEsProvider");\nvar EdDsaProvider = class extends EllipticProvider {\n  constructor() {\n    super(...arguments);\n    this.name = "EdDSA";\n    this.usages = {\n      privateKey: ["sign"],\n      publicKey: ["verify"]\n    };\n    this.namedCurves = ["Ed25519", "Ed448"];\n  }\n};\n__name(EdDsaProvider, "EdDsaProvider");\nvar ObjectIdentifier2 = /* @__PURE__ */ __name(class ObjectIdentifier3 {\n  constructor(value) {\n    if (value) {\n      this.value = value;\n    }\n  }\n}, "ObjectIdentifier");\n__decorate([\n  AsnProp({ type: AsnPropTypes.ObjectIdentifier })\n], ObjectIdentifier2.prototype, "value", void 0);\nObjectIdentifier2 = __decorate([\n  AsnType({ type: AsnTypeTypes.Choice })\n], ObjectIdentifier2);\nvar AlgorithmIdentifier = class {\n  constructor(params) {\n    Object.assign(this, params);\n  }\n};\n__name(AlgorithmIdentifier, "AlgorithmIdentifier");\n__decorate([\n  AsnProp({\n    type: AsnPropTypes.ObjectIdentifier\n  })\n], AlgorithmIdentifier.prototype, "algorithm", void 0);\n__decorate([\n  AsnProp({\n    type: AsnPropTypes.Any,\n    optional: true\n  })\n], AlgorithmIdentifier.prototype, "parameters", void 0);\nvar PrivateKeyInfo = class {\n  constructor() {\n    this.version = 0;\n    this.privateKeyAlgorithm = new AlgorithmIdentifier();\n    this.privateKey = new ArrayBuffer(0);\n  }\n};\n__name(PrivateKeyInfo, "PrivateKeyInfo");\n__decorate([\n  AsnProp({ type: AsnPropTypes.Integer })\n], PrivateKeyInfo.prototype, "version", void 0);\n__decorate([\n  AsnProp({ type: AlgorithmIdentifier })\n], PrivateKeyInfo.prototype, "privateKeyAlgorithm", void 0);\n__decorate([\n  AsnProp({ type: AsnPropTypes.OctetString })\n], PrivateKeyInfo.prototype, "privateKey", void 0);\n__decorate([\n  AsnProp({ type: AsnPropTypes.Any, optional: true })\n], PrivateKeyInfo.prototype, "attributes", void 0);\nvar PublicKeyInfo = class {\n  constructor() {\n    this.publicKeyAlgorithm = new AlgorithmIdentifier();\n    this.publicKey = new ArrayBuffer(0);\n  }\n};\n__name(PublicKeyInfo, "PublicKeyInfo");\n__decorate([\n  AsnProp({ type: AlgorithmIdentifier })\n], PublicKeyInfo.prototype, "publicKeyAlgorithm", void 0);\n__decorate([\n  AsnProp({ type: AsnPropTypes.BitString })\n], PublicKeyInfo.prototype, "publicKey", void 0);\nvar JsonBase64UrlArrayBufferConverter = {\n  fromJSON: (value) => Convert.FromBase64Url(value),\n  toJSON: (value) => Convert.ToBase64Url(new Uint8Array(value))\n};\nvar AsnIntegerArrayBufferConverter = {\n  fromASN: (value) => {\n    const valueHex = value.valueBlock.valueHex;\n    return !new Uint8Array(valueHex)[0] ? value.valueBlock.valueHex.slice(1) : value.valueBlock.valueHex;\n  },\n  toASN: (value) => {\n    const valueHex = new Uint8Array(value)[0] > 127 ? combine(new Uint8Array([0]).buffer, value) : value;\n    return new Integer({ valueHex });\n  }\n};\nvar RsaPrivateKey = class {\n  constructor() {\n    this.version = 0;\n    this.modulus = new ArrayBuffer(0);\n    this.publicExponent = new ArrayBuffer(0);\n    this.privateExponent = new ArrayBuffer(0);\n    this.prime1 = new ArrayBuffer(0);\n    this.prime2 = new ArrayBuffer(0);\n    this.exponent1 = new ArrayBuffer(0);\n    this.exponent2 = new ArrayBuffer(0);\n    this.coefficient = new ArrayBuffer(0);\n  }\n};\n__name(RsaPrivateKey, "RsaPrivateKey");\n__decorate([\n  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerConverter })\n], RsaPrivateKey.prototype, "version", void 0);\n__decorate([\n  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n  JsonProp({ name: "n", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, "modulus", void 0);\n__decorate([\n  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n  JsonProp({ name: "e", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, "publicExponent", void 0);\n__decorate([\n  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n  JsonProp({ name: "d", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, "privateExponent", void 0);\n__decorate([\n  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n  JsonProp({ name: "p", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, "prime1", void 0);\n__decorate([\n  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n  JsonProp({ name: "q", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, "prime2", void 0);\n__decorate([\n  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n  JsonProp({ name: "dp", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, "exponent1", void 0);\n__decorate([\n  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n  JsonProp({ name: "dq", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, "exponent2", void 0);\n__decorate([\n  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n  JsonProp({ name: "qi", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPrivateKey.prototype, "coefficient", void 0);\n__decorate([\n  AsnProp({ type: AsnPropTypes.Any, optional: true })\n], RsaPrivateKey.prototype, "otherPrimeInfos", void 0);\nvar RsaPublicKey = class {\n  constructor() {\n    this.modulus = new ArrayBuffer(0);\n    this.publicExponent = new ArrayBuffer(0);\n  }\n};\n__name(RsaPublicKey, "RsaPublicKey");\n__decorate([\n  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n  JsonProp({ name: "n", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPublicKey.prototype, "modulus", void 0);\n__decorate([\n  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerArrayBufferConverter }),\n  JsonProp({ name: "e", converter: JsonBase64UrlArrayBufferConverter })\n], RsaPublicKey.prototype, "publicExponent", void 0);\nvar EcPublicKey = /* @__PURE__ */ __name(class EcPublicKey2 {\n  constructor(value) {\n    this.value = new ArrayBuffer(0);\n    if (value) {\n      this.value = value;\n    }\n  }\n  toJSON() {\n    let bytes = new Uint8Array(this.value);\n    if (bytes[0] !== 4) {\n      throw new CryptoError("Wrong ECPoint. Current version supports only Uncompressed (0x04) point");\n    }\n    bytes = new Uint8Array(this.value.slice(1));\n    const size = bytes.length / 2;\n    const offset = 0;\n    const json = {\n      x: Convert.ToBase64Url(bytes.buffer.slice(offset, offset + size)),\n      y: Convert.ToBase64Url(bytes.buffer.slice(offset + size, offset + size + size))\n    };\n    return json;\n  }\n  fromJSON(json) {\n    if (!("x" in json)) {\n      throw new Error("x: Missing required property");\n    }\n    if (!("y" in json)) {\n      throw new Error("y: Missing required property");\n    }\n    const x = Convert.FromBase64Url(json.x);\n    const y = Convert.FromBase64Url(json.y);\n    const value = combine(new Uint8Array([4]).buffer, x, y);\n    this.value = new Uint8Array(value).buffer;\n    return this;\n  }\n}, "EcPublicKey");\n__decorate([\n  AsnProp({ type: AsnPropTypes.OctetString })\n], EcPublicKey.prototype, "value", void 0);\nEcPublicKey = __decorate([\n  AsnType({ type: AsnTypeTypes.Choice })\n], EcPublicKey);\nvar EcPrivateKey = class {\n  constructor() {\n    this.version = 1;\n    this.privateKey = new ArrayBuffer(0);\n  }\n  fromJSON(json) {\n    if (!("d" in json)) {\n      throw new Error("d: Missing required property");\n    }\n    this.privateKey = Convert.FromBase64Url(json.d);\n    if ("x" in json) {\n      const publicKey = new EcPublicKey();\n      publicKey.fromJSON(json);\n      const asn = AsnSerializer.toASN(publicKey);\n      if ("valueHex" in asn.valueBlock) {\n        this.publicKey = asn.valueBlock.valueHex;\n      }\n    }\n    return this;\n  }\n  toJSON() {\n    const jwk = {};\n    jwk.d = Convert.ToBase64Url(this.privateKey);\n    if (this.publicKey) {\n      Object.assign(jwk, new EcPublicKey(this.publicKey).toJSON());\n    }\n    return jwk;\n  }\n};\n__name(EcPrivateKey, "EcPrivateKey");\n__decorate([\n  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerConverter })\n], EcPrivateKey.prototype, "version", void 0);\n__decorate([\n  AsnProp({ type: AsnPropTypes.OctetString })\n], EcPrivateKey.prototype, "privateKey", void 0);\n__decorate([\n  AsnProp({ context: 0, type: AsnPropTypes.Any, optional: true })\n], EcPrivateKey.prototype, "parameters", void 0);\n__decorate([\n  AsnProp({ context: 1, type: AsnPropTypes.BitString, optional: true })\n], EcPrivateKey.prototype, "publicKey", void 0);\nvar AsnIntegerWithoutPaddingConverter = {\n  fromASN: (value) => {\n    const bytes = new Uint8Array(value.valueBlock.valueHex);\n    return bytes[0] === 0 ? bytes.buffer.slice(1) : bytes.buffer;\n  },\n  toASN: (value) => {\n    const bytes = new Uint8Array(value);\n    if (bytes[0] > 127) {\n      const newValue = new Uint8Array(bytes.length + 1);\n      newValue.set(bytes, 1);\n      return new Integer({ valueHex: newValue.buffer });\n    }\n    return new Integer({ valueHex: value });\n  }\n};\nvar index$2 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  AsnIntegerWithoutPaddingConverter\n});\nvar EcUtils = class {\n  static decodePoint(data, pointSize) {\n    const view = BufferSourceConverter.toUint8Array(data);\n    if (view.length === 0 || view[0] !== 4) {\n      throw new Error("Only uncompressed point format supported");\n    }\n    const n = (view.length - 1) / 2;\n    if (n !== Math.ceil(pointSize / 8)) {\n      throw new Error("Point does not match field size");\n    }\n    const xb = view.slice(1, n + 1);\n    const yb = view.slice(n + 1, n + 1 + n);\n    return { x: xb, y: yb };\n  }\n  static encodePoint(point, pointSize) {\n    const size = Math.ceil(pointSize / 8);\n    if (point.x.byteLength !== size || point.y.byteLength !== size) {\n      throw new Error("X,Y coordinates don\'t match point size criteria");\n    }\n    const x = BufferSourceConverter.toUint8Array(point.x);\n    const y = BufferSourceConverter.toUint8Array(point.y);\n    const res = new Uint8Array(size * 2 + 1);\n    res[0] = 4;\n    res.set(x, 1);\n    res.set(y, size + 1);\n    return res;\n  }\n  static getSize(pointSize) {\n    return Math.ceil(pointSize / 8);\n  }\n  static encodeSignature(signature, pointSize) {\n    const size = this.getSize(pointSize);\n    const r = BufferSourceConverter.toUint8Array(signature.r);\n    const s = BufferSourceConverter.toUint8Array(signature.s);\n    const res = new Uint8Array(size * 2);\n    res.set(this.padStart(r, size));\n    res.set(this.padStart(s, size), size);\n    return res;\n  }\n  static decodeSignature(data, pointSize) {\n    const size = this.getSize(pointSize);\n    const view = BufferSourceConverter.toUint8Array(data);\n    if (view.length !== size * 2) {\n      throw new Error("Incorrect size of the signature");\n    }\n    const r = view.slice(0, size);\n    const s = view.slice(size);\n    return {\n      r: this.trimStart(r),\n      s: this.trimStart(s)\n    };\n  }\n  static trimStart(data) {\n    let i = 0;\n    while (i < data.length - 1 && data[i] === 0) {\n      i++;\n    }\n    if (i === 0) {\n      return data;\n    }\n    return data.slice(i, data.length);\n  }\n  static padStart(data, size) {\n    if (size === data.length) {\n      return data;\n    }\n    const res = new Uint8Array(size);\n    res.set(data, size - data.length);\n    return res;\n  }\n};\n__name(EcUtils, "EcUtils");\nvar EcDsaSignature = class {\n  constructor() {\n    this.r = new ArrayBuffer(0);\n    this.s = new ArrayBuffer(0);\n  }\n  static fromWebCryptoSignature(value) {\n    const pointSize = value.byteLength / 2;\n    const point = EcUtils.decodeSignature(value, pointSize * 8);\n    const ecSignature = new EcDsaSignature();\n    ecSignature.r = BufferSourceConverter.toArrayBuffer(point.r);\n    ecSignature.s = BufferSourceConverter.toArrayBuffer(point.s);\n    return ecSignature;\n  }\n  toWebCryptoSignature(pointSize) {\n    pointSize !== null && pointSize !== void 0 ? pointSize : pointSize = Math.max(this.r.byteLength, this.s.byteLength) * 8;\n    const signature = EcUtils.encodeSignature(this, pointSize);\n    return signature.buffer;\n  }\n};\n__name(EcDsaSignature, "EcDsaSignature");\n__decorate([\n  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerWithoutPaddingConverter })\n], EcDsaSignature.prototype, "r", void 0);\n__decorate([\n  AsnProp({ type: AsnPropTypes.Integer, converter: AsnIntegerWithoutPaddingConverter })\n], EcDsaSignature.prototype, "s", void 0);\nvar OneAsymmetricKey = class extends PrivateKeyInfo {\n};\n__name(OneAsymmetricKey, "OneAsymmetricKey");\n__decorate([\n  AsnProp({ context: 1, implicit: true, type: AsnPropTypes.BitString, optional: true })\n], OneAsymmetricKey.prototype, "publicKey", void 0);\nvar EdPrivateKey = /* @__PURE__ */ __name(class EdPrivateKey2 {\n  constructor() {\n    this.value = new ArrayBuffer(0);\n  }\n  fromJSON(json) {\n    if (!json.d) {\n      throw new Error("d: Missing required property");\n    }\n    this.value = Convert.FromBase64Url(json.d);\n    return this;\n  }\n  toJSON() {\n    const jwk = {\n      d: Convert.ToBase64Url(this.value)\n    };\n    return jwk;\n  }\n}, "EdPrivateKey");\n__decorate([\n  AsnProp({ type: AsnPropTypes.OctetString })\n], EdPrivateKey.prototype, "value", void 0);\nEdPrivateKey = __decorate([\n  AsnType({ type: AsnTypeTypes.Choice })\n], EdPrivateKey);\nvar EdPublicKey = /* @__PURE__ */ __name(class EdPublicKey2 {\n  constructor(value) {\n    this.value = new ArrayBuffer(0);\n    if (value) {\n      this.value = value;\n    }\n  }\n  toJSON() {\n    const json = {\n      x: Convert.ToBase64Url(this.value)\n    };\n    return json;\n  }\n  fromJSON(json) {\n    if (!("x" in json)) {\n      throw new Error("x: Missing required property");\n    }\n    this.value = Convert.FromBase64Url(json.x);\n    return this;\n  }\n}, "EdPublicKey");\n__decorate([\n  AsnProp({ type: AsnPropTypes.BitString })\n], EdPublicKey.prototype, "value", void 0);\nEdPublicKey = __decorate([\n  AsnType({ type: AsnTypeTypes.Choice })\n], EdPublicKey);\nvar CurvePrivateKey = /* @__PURE__ */ __name(class CurvePrivateKey2 {\n}, "CurvePrivateKey");\n__decorate([\n  AsnProp({ type: AsnPropTypes.OctetString }),\n  JsonProp({ type: JsonPropTypes.String, converter: JsonBase64UrlArrayBufferConverter })\n], CurvePrivateKey.prototype, "d", void 0);\nCurvePrivateKey = __decorate([\n  AsnType({ type: AsnTypeTypes.Choice })\n], CurvePrivateKey);\nvar idSecp256r1 = "1.2.840.10045.3.1.7";\nvar idEllipticCurve = "1.3.132.0";\nvar idSecp384r1 = `${idEllipticCurve}.34`;\nvar idSecp521r1 = `${idEllipticCurve}.35`;\nvar idSecp256k1 = `${idEllipticCurve}.10`;\nvar idVersionOne = "1.3.36.3.3.2.8.1.1";\nvar idBrainpoolP160r1 = `${idVersionOne}.1`;\nvar idBrainpoolP160t1 = `${idVersionOne}.2`;\nvar idBrainpoolP192r1 = `${idVersionOne}.3`;\nvar idBrainpoolP192t1 = `${idVersionOne}.4`;\nvar idBrainpoolP224r1 = `${idVersionOne}.5`;\nvar idBrainpoolP224t1 = `${idVersionOne}.6`;\nvar idBrainpoolP256r1 = `${idVersionOne}.7`;\nvar idBrainpoolP256t1 = `${idVersionOne}.8`;\nvar idBrainpoolP320r1 = `${idVersionOne}.9`;\nvar idBrainpoolP320t1 = `${idVersionOne}.10`;\nvar idBrainpoolP384r1 = `${idVersionOne}.11`;\nvar idBrainpoolP384t1 = `${idVersionOne}.12`;\nvar idBrainpoolP512r1 = `${idVersionOne}.13`;\nvar idBrainpoolP512t1 = `${idVersionOne}.14`;\nvar idX25519 = "1.3.101.110";\nvar idX448 = "1.3.101.111";\nvar idEd25519 = "1.3.101.112";\nvar idEd448 = "1.3.101.113";\nvar index$1 = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  AlgorithmIdentifier,\n  get CurvePrivateKey() {\n    return CurvePrivateKey;\n  },\n  EcDsaSignature,\n  EcPrivateKey,\n  get EcPublicKey() {\n    return EcPublicKey;\n  },\n  get EdPrivateKey() {\n    return EdPrivateKey;\n  },\n  get EdPublicKey() {\n    return EdPublicKey;\n  },\n  get ObjectIdentifier() {\n    return ObjectIdentifier2;\n  },\n  OneAsymmetricKey,\n  PrivateKeyInfo,\n  PublicKeyInfo,\n  RsaPrivateKey,\n  RsaPublicKey,\n  converters: index$2,\n  idBrainpoolP160r1,\n  idBrainpoolP160t1,\n  idBrainpoolP192r1,\n  idBrainpoolP192t1,\n  idBrainpoolP224r1,\n  idBrainpoolP224t1,\n  idBrainpoolP256r1,\n  idBrainpoolP256t1,\n  idBrainpoolP320r1,\n  idBrainpoolP320t1,\n  idBrainpoolP384r1,\n  idBrainpoolP384t1,\n  idBrainpoolP512r1,\n  idBrainpoolP512t1,\n  idEd25519,\n  idEd448,\n  idEllipticCurve,\n  idSecp256k1,\n  idSecp256r1,\n  idSecp384r1,\n  idSecp521r1,\n  idVersionOne,\n  idX25519,\n  idX448\n});\nvar EcCurves = class {\n  constructor() {\n  }\n  static register(item) {\n    const oid = new ObjectIdentifier2();\n    oid.value = item.id;\n    const raw = AsnConvert.serialize(oid);\n    this.items.push({\n      ...item,\n      raw\n    });\n    this.names.push(item.name);\n  }\n  static find(nameOrId) {\n    nameOrId = nameOrId.toUpperCase();\n    for (const item of this.items) {\n      if (item.name.toUpperCase() === nameOrId || item.id.toUpperCase() === nameOrId) {\n        return item;\n      }\n    }\n    return null;\n  }\n  static get(nameOrId) {\n    const res = this.find(nameOrId);\n    if (!res) {\n      throw new Error(`Unsupported EC named curve \'${nameOrId}\'`);\n    }\n    return res;\n  }\n};\n__name(EcCurves, "EcCurves");\nEcCurves.items = [];\nEcCurves.names = [];\nEcCurves.register({ name: "P-256", id: idSecp256r1, size: 256 });\nEcCurves.register({ name: "P-384", id: idSecp384r1, size: 384 });\nEcCurves.register({ name: "P-521", id: idSecp521r1, size: 521 });\nEcCurves.register({ name: "K-256", id: idSecp256k1, size: 256 });\nEcCurves.register({ name: "brainpoolP160r1", id: idBrainpoolP160r1, size: 160 });\nEcCurves.register({ name: "brainpoolP160t1", id: idBrainpoolP160t1, size: 160 });\nEcCurves.register({ name: "brainpoolP192r1", id: idBrainpoolP192r1, size: 192 });\nEcCurves.register({ name: "brainpoolP192t1", id: idBrainpoolP192t1, size: 192 });\nEcCurves.register({ name: "brainpoolP224r1", id: idBrainpoolP224r1, size: 224 });\nEcCurves.register({ name: "brainpoolP224t1", id: idBrainpoolP224t1, size: 224 });\nEcCurves.register({ name: "brainpoolP256r1", id: idBrainpoolP256r1, size: 256 });\nEcCurves.register({ name: "brainpoolP256t1", id: idBrainpoolP256t1, size: 256 });\nEcCurves.register({ name: "brainpoolP320r1", id: idBrainpoolP320r1, size: 320 });\nEcCurves.register({ name: "brainpoolP320t1", id: idBrainpoolP320t1, size: 320 });\nEcCurves.register({ name: "brainpoolP384r1", id: idBrainpoolP384r1, size: 384 });\nEcCurves.register({ name: "brainpoolP384t1", id: idBrainpoolP384t1, size: 384 });\nEcCurves.register({ name: "brainpoolP512r1", id: idBrainpoolP512r1, size: 512 });\nEcCurves.register({ name: "brainpoolP512t1", id: idBrainpoolP512t1, size: 512 });\nvar HmacProvider = class extends ProviderCrypto {\n  constructor() {\n    super(...arguments);\n    this.name = "HMAC";\n    this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];\n    this.usages = ["sign", "verify"];\n  }\n  getDefaultLength(algName) {\n    switch (algName.toUpperCase()) {\n      case "SHA-1":\n      case "SHA-256":\n      case "SHA-384":\n      case "SHA-512":\n        return 512;\n      default:\n        throw new Error(`Unknown algorithm name \'${algName}\'`);\n    }\n  }\n  checkGenerateKeyParams(algorithm) {\n    this.checkRequiredProperty(algorithm, "hash");\n    this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    if ("length" in algorithm) {\n      if (typeof algorithm.length !== "number") {\n        throw new TypeError("length: Is not a Number");\n      }\n      if (algorithm.length < 1) {\n        throw new RangeError("length: Number is out of range");\n      }\n    }\n  }\n  checkImportParams(algorithm) {\n    this.checkRequiredProperty(algorithm, "hash");\n    this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n  }\n};\n__name(HmacProvider, "HmacProvider");\nvar Pbkdf2Provider = class extends ProviderCrypto {\n  constructor() {\n    super(...arguments);\n    this.name = "PBKDF2";\n    this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];\n    this.usages = ["deriveBits", "deriveKey"];\n  }\n  checkAlgorithmParams(algorithm) {\n    this.checkRequiredProperty(algorithm, "hash");\n    this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    this.checkRequiredProperty(algorithm, "salt");\n    if (!(algorithm.salt instanceof ArrayBuffer || ArrayBuffer.isView(algorithm.salt))) {\n      throw new TypeError("salt: Is not of type \'(ArrayBuffer or ArrayBufferView)\'");\n    }\n    this.checkRequiredProperty(algorithm, "iterations");\n    if (typeof algorithm.iterations !== "number") {\n      throw new TypeError("iterations: Is not a Number");\n    }\n    if (algorithm.iterations < 1) {\n      throw new TypeError("iterations: Is less than 1");\n    }\n  }\n  checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n    super.checkImportKey(format, keyData, algorithm, extractable, keyUsages);\n    if (extractable) {\n      throw new SyntaxError("extractable: Must be \'false\'");\n    }\n  }\n};\n__name(Pbkdf2Provider, "Pbkdf2Provider");\nvar HkdfProvider = class extends ProviderCrypto {\n  constructor() {\n    super(...arguments);\n    this.name = "HKDF";\n    this.hashAlgorithms = ["SHA-1", "SHA-256", "SHA-384", "SHA-512"];\n    this.usages = ["deriveKey", "deriveBits"];\n  }\n  checkAlgorithmParams(algorithm) {\n    this.checkRequiredProperty(algorithm, "hash");\n    this.checkHashAlgorithm(algorithm.hash, this.hashAlgorithms);\n    this.checkRequiredProperty(algorithm, "salt");\n    if (!BufferSourceConverter.isBufferSource(algorithm.salt)) {\n      throw new TypeError("salt: Is not of type \'(ArrayBuffer or ArrayBufferView)\'");\n    }\n    this.checkRequiredProperty(algorithm, "info");\n    if (!BufferSourceConverter.isBufferSource(algorithm.info)) {\n      throw new TypeError("salt: Is not of type \'(ArrayBuffer or ArrayBufferView)\'");\n    }\n  }\n  checkImportKey(format, keyData, algorithm, extractable, keyUsages, ...args) {\n    super.checkImportKey(format, keyData, algorithm, extractable, keyUsages);\n    if (extractable) {\n      throw new SyntaxError("extractable: Must be \'false\'");\n    }\n  }\n};\n__name(HkdfProvider, "HkdfProvider");\nvar ShakeProvider = class extends ProviderCrypto {\n  constructor() {\n    super(...arguments);\n    this.usages = [];\n    this.defaultLength = 0;\n  }\n  digest(...args) {\n    args[0] = { length: this.defaultLength, ...args[0] };\n    return super.digest.apply(this, args);\n  }\n  checkDigest(algorithm, data) {\n    super.checkDigest(algorithm, data);\n    const length = algorithm.length || 0;\n    if (typeof length !== "number") {\n      throw new TypeError("length: Is not a Number");\n    }\n    if (length < 0) {\n      throw new TypeError("length: Is negative");\n    }\n  }\n};\n__name(ShakeProvider, "ShakeProvider");\nvar Shake128Provider = class extends ShakeProvider {\n  constructor() {\n    super(...arguments);\n    this.name = "shake128";\n    this.defaultLength = 16;\n  }\n};\n__name(Shake128Provider, "Shake128Provider");\nvar Shake256Provider = class extends ShakeProvider {\n  constructor() {\n    super(...arguments);\n    this.name = "shake256";\n    this.defaultLength = 32;\n  }\n};\n__name(Shake256Provider, "Shake256Provider");\nvar Crypto = class {\n  get [Symbol.toStringTag]() {\n    return "Crypto";\n  }\n  randomUUID() {\n    const b = this.getRandomValues(new Uint8Array(16));\n    b[6] = b[6] & 15 | 64;\n    b[8] = b[8] & 63 | 128;\n    const uuid = Convert.ToHex(b).toLowerCase();\n    return `${uuid.substring(0, 8)}-${uuid.substring(8, 12)}-${uuid.substring(12, 16)}-${uuid.substring(16, 20)}-${uuid.substring(20)}`;\n  }\n};\n__name(Crypto, "Crypto");\nvar ProviderStorage = class {\n  constructor() {\n    this.items = {};\n  }\n  get(algorithmName) {\n    return this.items[algorithmName.toLowerCase()] || null;\n  }\n  set(provider) {\n    this.items[provider.name.toLowerCase()] = provider;\n  }\n  removeAt(algorithmName) {\n    const provider = this.get(algorithmName.toLowerCase());\n    if (provider) {\n      delete this.items[algorithmName];\n    }\n    return provider;\n  }\n  has(name) {\n    return !!this.get(name);\n  }\n  get length() {\n    return Object.keys(this.items).length;\n  }\n  get algorithms() {\n    const algorithms = [];\n    for (const key in this.items) {\n      const provider = this.items[key];\n      algorithms.push(provider.name);\n    }\n    return algorithms.sort();\n  }\n};\n__name(ProviderStorage, "ProviderStorage");\nvar SubtleCrypto = class {\n  constructor() {\n    this.providers = new ProviderStorage();\n  }\n  static isHashedAlgorithm(data) {\n    return data && typeof data === "object" && "name" in data && "hash" in data ? true : false;\n  }\n  get [Symbol.toStringTag]() {\n    return "SubtleCrypto";\n  }\n  async digest(...args) {\n    this.checkRequiredArguments(args, 2, "digest");\n    const [algorithm, data, ...params] = args;\n    const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n    const preparedData = BufferSourceConverter.toArrayBuffer(data);\n    const provider = this.getProvider(preparedAlgorithm.name);\n    const result = await provider.digest(preparedAlgorithm, preparedData, ...params);\n    return result;\n  }\n  async generateKey(...args) {\n    this.checkRequiredArguments(args, 3, "generateKey");\n    const [algorithm, extractable, keyUsages, ...params] = args;\n    const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n    const provider = this.getProvider(preparedAlgorithm.name);\n    const result = await provider.generateKey({ ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);\n    return result;\n  }\n  async sign(...args) {\n    this.checkRequiredArguments(args, 3, "sign");\n    const [algorithm, key, data, ...params] = args;\n    this.checkCryptoKey(key);\n    const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n    const preparedData = BufferSourceConverter.toArrayBuffer(data);\n    const provider = this.getProvider(preparedAlgorithm.name);\n    const result = await provider.sign({ ...preparedAlgorithm, name: provider.name }, key, preparedData, ...params);\n    return result;\n  }\n  async verify(...args) {\n    this.checkRequiredArguments(args, 4, "verify");\n    const [algorithm, key, signature, data, ...params] = args;\n    this.checkCryptoKey(key);\n    const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n    const preparedData = BufferSourceConverter.toArrayBuffer(data);\n    const preparedSignature = BufferSourceConverter.toArrayBuffer(signature);\n    const provider = this.getProvider(preparedAlgorithm.name);\n    const result = await provider.verify({ ...preparedAlgorithm, name: provider.name }, key, preparedSignature, preparedData, ...params);\n    return result;\n  }\n  async encrypt(...args) {\n    this.checkRequiredArguments(args, 3, "encrypt");\n    const [algorithm, key, data, ...params] = args;\n    this.checkCryptoKey(key);\n    const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n    const preparedData = BufferSourceConverter.toArrayBuffer(data);\n    const provider = this.getProvider(preparedAlgorithm.name);\n    const result = await provider.encrypt({ ...preparedAlgorithm, name: provider.name }, key, preparedData, { keyUsage: true }, ...params);\n    return result;\n  }\n  async decrypt(...args) {\n    this.checkRequiredArguments(args, 3, "decrypt");\n    const [algorithm, key, data, ...params] = args;\n    this.checkCryptoKey(key);\n    const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n    const preparedData = BufferSourceConverter.toArrayBuffer(data);\n    const provider = this.getProvider(preparedAlgorithm.name);\n    const result = await provider.decrypt({ ...preparedAlgorithm, name: provider.name }, key, preparedData, { keyUsage: true }, ...params);\n    return result;\n  }\n  async deriveBits(...args) {\n    this.checkRequiredArguments(args, 3, "deriveBits");\n    const [algorithm, baseKey, length, ...params] = args;\n    this.checkCryptoKey(baseKey);\n    const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n    const provider = this.getProvider(preparedAlgorithm.name);\n    const result = await provider.deriveBits({ ...preparedAlgorithm, name: provider.name }, baseKey, length, { keyUsage: true }, ...params);\n    return result;\n  }\n  async deriveKey(...args) {\n    this.checkRequiredArguments(args, 5, "deriveKey");\n    const [algorithm, baseKey, derivedKeyType, extractable, keyUsages, ...params] = args;\n    const preparedDerivedKeyType = this.prepareAlgorithm(derivedKeyType);\n    const importProvider = this.getProvider(preparedDerivedKeyType.name);\n    importProvider.checkDerivedKeyParams(preparedDerivedKeyType);\n    const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n    const provider = this.getProvider(preparedAlgorithm.name);\n    provider.checkCryptoKey(baseKey, "deriveKey");\n    const derivedBits = await provider.deriveBits({ ...preparedAlgorithm, name: provider.name }, baseKey, derivedKeyType.length || 512, { keyUsage: false }, ...params);\n    return this.importKey("raw", derivedBits, derivedKeyType, extractable, keyUsages, ...params);\n  }\n  async exportKey(...args) {\n    this.checkRequiredArguments(args, 2, "exportKey");\n    const [format, key, ...params] = args;\n    this.checkCryptoKey(key);\n    const provider = this.getProvider(key.algorithm.name);\n    const result = await provider.exportKey(format, key, ...params);\n    return result;\n  }\n  async importKey(...args) {\n    this.checkRequiredArguments(args, 5, "importKey");\n    const [format, keyData, algorithm, extractable, keyUsages, ...params] = args;\n    const preparedAlgorithm = this.prepareAlgorithm(algorithm);\n    const provider = this.getProvider(preparedAlgorithm.name);\n    if (["pkcs8", "spki", "raw"].indexOf(format) !== -1) {\n      const preparedData = BufferSourceConverter.toArrayBuffer(keyData);\n      return provider.importKey(format, preparedData, { ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);\n    } else {\n      if (!keyData.kty) {\n        throw new TypeError("keyData: Is not JSON");\n      }\n    }\n    return provider.importKey(format, keyData, { ...preparedAlgorithm, name: provider.name }, extractable, keyUsages, ...params);\n  }\n  async wrapKey(format, key, wrappingKey, wrapAlgorithm, ...args) {\n    let keyData = await this.exportKey(format, key, ...args);\n    if (format === "jwk") {\n      const json = JSON.stringify(keyData);\n      keyData = Convert.FromUtf8String(json);\n    }\n    const preparedAlgorithm = this.prepareAlgorithm(wrapAlgorithm);\n    const preparedData = BufferSourceConverter.toArrayBuffer(keyData);\n    const provider = this.getProvider(preparedAlgorithm.name);\n    return provider.encrypt({ ...preparedAlgorithm, name: provider.name }, wrappingKey, preparedData, { keyUsage: false }, ...args);\n  }\n  async unwrapKey(format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages, ...args) {\n    const preparedAlgorithm = this.prepareAlgorithm(unwrapAlgorithm);\n    const preparedData = BufferSourceConverter.toArrayBuffer(wrappedKey);\n    const provider = this.getProvider(preparedAlgorithm.name);\n    let keyData = await provider.decrypt({ ...preparedAlgorithm, name: provider.name }, unwrappingKey, preparedData, { keyUsage: false }, ...args);\n    if (format === "jwk") {\n      try {\n        keyData = JSON.parse(Convert.ToUtf8String(keyData));\n      } catch (e) {\n        const error = new TypeError("wrappedKey: Is not a JSON");\n        error.internal = e;\n        throw error;\n      }\n    }\n    return this.importKey(format, keyData, unwrappedKeyAlgorithm, extractable, keyUsages, ...args);\n  }\n  checkRequiredArguments(args, size, methodName) {\n    if (args.length < size) {\n      throw new TypeError(`Failed to execute \'${methodName}\' on \'SubtleCrypto\': ${size} arguments required, but only ${args.length} present`);\n    }\n  }\n  prepareAlgorithm(algorithm) {\n    if (typeof algorithm === "string") {\n      return {\n        name: algorithm\n      };\n    }\n    if (SubtleCrypto.isHashedAlgorithm(algorithm)) {\n      const preparedAlgorithm = { ...algorithm };\n      preparedAlgorithm.hash = th